! L2 complex HZ.
SUBROUTINE ZHZL2(M,N,K, Y,YU,LDY, W,WV,LDW, J, Z,ZZ,LDZ, IAM,CPR, JS,NSWP,&
     NCOLSB,IFCOLB, JSPIN1,JSPIN2,JSPAIR,JSCOMM, PSHBUF,PSTATS, E,SS, EY,SY, EW,SW,&
     BH,BS,BZ,LDB, IWORK, INFO)
  USE TIMER
  IMPLICIT NONE

  INTEGER, INTENT(IN) :: M,N,K, LDY,LDW,LDZ, J(M),LDB, IAM,CPR, NSWP(2)
  COMPLEX(KIND=DWP), INTENT(INOUT), TARGET :: Y(LDY,K),W(LDW,K),Z(LDZ,K)
  COMPLEX(KIND=DWP), INTENT(OUT), TARGET :: YU(LDY,K),WV(LDW,K),ZZ(LDZ,K)
  INTEGER, INTENT(IN) :: NCOLSB(2*CPR),IFCOLB(2*CPR)
  INTEGER, INTENT(IN), TARGET :: JS(JSMLEX,3), JSPIN1(2,JS(JSMLEX,1),JS(JSMLEX-1,1)),JSPIN2(2,JS(JSMLEX,2),JS(JSMLEX-1,2))
  INTEGER, INTENT(IN) :: JSPAIR(2,JS(JSMLEX,3),JS(JSMLEX-1,3)),JSCOMM(2,JS(JSMLEX,3),JS(JSMLEX-1,3))
  TYPE(ZSHENT), INTENT(IN) :: PSHBUF(CPR)
  REAL(KIND=DWP), INTENT(OUT) :: E(K),SS(K), EY(K),SY(K), EW(K),SW(K)
  COMPLEX(KIND=DWP), INTENT(OUT) :: BH(LDB,K),BS(LDB,K),BZ(LDB,K)
  INTEGER, INTENT(OUT), TARGET :: IWORK(2*((M/2)+MOD(M,2))+6*K)
  INTEGER, INTENT(OUT) :: PSTATS(8), INFO

  INTEGER, POINTER, CONTIGUOUS :: JSINT(:),JSPINT(:,:,:), JNSTIX(:),JNLENS(:), IPIV(:),JVEC(:),IPL(:),INVP(:)

  COMPLEX(KIND=DWP) :: ZTMP
  REAL(KIND=DWP) :: DTMP
  INTEGER :: I,L, P,Q, JSINTN
  INTEGER :: NPLUS, JNBLKS, BNPLUS
  INTEGER :: NCP,NCQ,NCB,MXNC
  INTEGER :: IFCP,IFCQ
  INTEGER :: BSWP,NBSTEPS,BSTEP
  INTEGER :: INFO2(2), TNS
  LOGICAL :: LNOROT

#ifndef NDEBUG
  LOGICAL(c_int) :: LFHALT(5)
#endif

  EXTERNAL :: ZDSCAL, ZLACPY,ZLASSQ

  !DIR$ ASSUME_ALIGNED Y:ALIGNB
  !DIR$ ASSUME_ALIGNED W:ALIGNB
  !DIR$ ASSUME_ALIGNED Z:ALIGNB
  !DIR$ ASSUME_ALIGNED J:ALIGNB
  !DIR$ ASSUME_ALIGNED YU:ALIGNB
  !DIR$ ASSUME_ALIGNED WV:ALIGNB
  !DIR$ ASSUME_ALIGNED ZZ:ALIGNB
  !DIR$ ASSUME_ALIGNED JS:ALIGNB
  !DIR$ ASSUME_ALIGNED JSPIN1:ALIGNB
  !DIR$ ASSUME_ALIGNED JSPIN2:ALIGNB
  !DIR$ ASSUME_ALIGNED JSPAIR:ALIGNB
  !DIR$ ASSUME_ALIGNED JSCOMM:ALIGNB
  !DIR$ ASSUME_ALIGNED E:ALIGNB
  !DIR$ ASSUME_ALIGNED SS:ALIGNB
  !DIR$ ASSUME_ALIGNED EY:ALIGNB
  !DIR$ ASSUME_ALIGNED SY:ALIGNB
  !DIR$ ASSUME_ALIGNED EW:ALIGNB
  !DIR$ ASSUME_ALIGNED SW:ALIGNB
  !DIR$ ASSUME_ALIGNED BH:ALIGNB
  !DIR$ ASSUME_ALIGNED BS:ALIGNB
  !DIR$ ASSUME_ALIGNED BZ:ALIGNB
  !DIR$ ASSUME_ALIGNED IWORK:ALIGNB

  IF (M .LT. 0) THEN
     INFO = -1
  ELSE IF (N .LT. 0) THEN
     INFO = -2
  ELSE IF (N .GT. M) THEN
     INFO = -2
  ELSE IF (K .LT. 0) THEN
     INFO = -3
  ELSE IF (MOD(K,2) .NE. 0) THEN
     INFO = -3
  ELSE IF (LDY .LT. M) THEN
     INFO = -6
  ELSE IF (LDW .LT. M) THEN
     INFO = -9
  ELSE IF (LDZ .LT. N) THEN
     INFO = -13
  ELSE IF (IAM .LT. 1) THEN
     INFO = -14
  ELSE IF (IAM .GT. CPR) THEN
     INFO = -14
  ELSE IF (CPR .LT. 1) THEN
     INFO = -15
  ELSE IF (CPR .GT. MAXCPR) THEN
     INFO = -15
  ELSE IF (NSWP(1) .LT. 0) THEN
     INFO = -16
  ELSE IF (NSWP(2) .LT. 0) THEN
     INFO = -16
  ELSE IF (LDB .LT. K) THEN
     INFO = -34
  ELSE IF (MOD(LDB,ZALIGN) .NE. 0) THEN
     INFO = -34
  ELSE
     INFO = 0
  END IF
  IF (INFO .NE. 0) RETURN

  !$OMP MASTER
  DO L = 1, 8
     !$OMP ATOMIC WRITE
     PSTATS(L) = 0
     !$OMP END ATOMIC
  END DO
  !$OMP END MASTER

#ifndef NDEBUG
  DO L = 1, 5
     CALL IEEE_GET_HALTING_MODE(IEEE_ALL(L), LFHALT(L))
  END DO
  CALL IEEE_SET_HALTING_MODE(IEEE_OVERFLOW, .TRUE._c_int)
  CALL IEEE_SET_HALTING_MODE(IEEE_DIVIDE_BY_ZERO, .TRUE._c_int)
  CALL IEEE_SET_HALTING_MODE(IEEE_INVALID, .TRUE._c_int)
  CALL IEEE_SET_HALTING_MODE(IEEE_UNDERFLOW, .FALSE._c_int)
  CALL IEEE_SET_HALTING_MODE(IEEE_INEXACT, .FALSE._c_int)
#endif

  ! Partition IWORK, the integer workspace.
  JNBLKS = (M / 2) + MOD(M, 2)

  I = 1
  JNSTIX => IWORK(I:I+JNBLKS-1)

  I = I + JNBLKS
  JNLENS => IWORK(I:I+JNBLKS-1)

  I = I + JNBLKS
  IPIV => IWORK(I:I+2*K-1)

  I = I + 2*K
  JVEC => IWORK(I:I+2*K-1)

  I = I + 2*K
  IPL => IWORK(I:I+K-1)

  I = I + K
  INVP => IWORK(I:I+K-1)

  MXNC = K / 2
  NBSTEPS = JS(JSMLEX-1,3)

  ! Analyse the non-unity blocks of J.
  CALL JANAL(M, J, NPLUS, JNBLKS, JNSTIX,JNLENS)
  !$OMP BARRIER

  ! Z = partOf(I)
  BSTEP = 1
  P = JSPAIR(1,IAM,BSTEP)
  NCP = NCOLSB(P)
  Q = JSPAIR(2,IAM,BSTEP)
  NCQ = NCOLSB(Q)
  NCB = NCP + NCQ
  IFCP = IFCOLB(P)
  IFCQ = IFCOLB(Q)
  I = 1 + (MXNC - NCP)
  CALL ZSETZI(N,NCP,NCQ, Z(1,I),Z(1,1+MXNC),N, IFCP,IFCQ)

  ! BEGIN MAIN LOOP

  DO BSWP = 1, NSWP(2)
     DO BSTEP = 1, NBSTEPS
        P = JSPAIR(1,IAM,BSTEP)
        Q = JSPAIR(2,IAM,BSTEP)
        NCP = NCOLSB(P)
        NCQ = NCOLSB(Q)
        NCB = NCP + NCQ
        IF (NCP .LT. MXNC) THEN
           JSINT => JS(1:JSMLEX,1)
           JSPINT => JSPIN1
           I = 1 + (MXNC - NCP)
        ELSE
           JSINT => JS(1:JSMLEX,2)
           JSPINT => JSPIN2
           I = 1
        END IF
        JSINTN = JSINT(2)

        TNS = GET_THREAD_NS()
        CALL ZPREP_BLKS(M,NCB,K, Y(1,I),YU(1,I),LDY, W(1,I),LDW,&
             JNSTIX,JNLENS,JNBLKS,NPLUS,&
             IPIV,JVEC,IPL,INVP, BNPLUS, BH,BS,BZ,LDB, INFO2)
        TNS = GET_THREAD_NS() - TNS

        !$OMP ATOMIC UPDATE
        PSTATS(1) = MAX(PSTATS(1), TNS)
        !$OMP END ATOMIC

        IF (INFO2(1) .NE. 0) THEN
           WRITE (ULOG,'(A,2(I4,A),3(I3,A),I11)') 'BH:',BSWP,',',BSTEP,';',IAM,',',P,',',Q,',',INFO2(1)
           STOP 'ZHZL2: BH INFO .LT. 0'
        END IF
        IF (INFO2(2) .NE. 0) THEN
           WRITE (ULOG,'(A,2(I4,A),3(I3,A),I11)') 'BS:',BSWP,',',BSTEP,';',IAM,',',P,',',Q,',',INFO2(2)
           STOP 'ZHZL2: BS INFO .LT. 0'
        END IF

        ! # of rotations (all,big) => INFO2
        TNS = GET_THREAD_NS()
        CALL ZHZL1(JSINTN, BH,BNPLUS, BS,BZ, LDB, JSINT,JSPINT, NSWP(1), INFO2,INFO)
        TNS = GET_THREAD_NS() - TNS

        !$OMP ATOMIC UPDATE
        PSTATS(2) = MAX(PSTATS(2), TNS)
        !$OMP END ATOMIC

        IF (INFO2(1) .GT. 0) THEN
           !$OMP ATOMIC UPDATE
           PSTATS(4) = PSTATS(4) + INFO2(1)
           !$OMP END ATOMIC
           LNOROT = .FALSE.
        ELSE IF (INFO2(1) .EQ. 0) THEN
           LNOROT = .TRUE.
#ifndef NDEBUG
        ELSE
           STOP 'ZHZL2: ALLROT < 0'
#endif
        END IF
#ifndef NDEBUG
        IF (INFO2(2) .GT. INFO2(1)) STOP 'ZHZL2: BIGROT > ALLROT'
#endif
        IF (INFO2(2) .GT. 0) THEN
           !$OMP ATOMIC UPDATE
           PSTATS(5) = PSTATS(5) + INFO2(2)
           !$OMP END ATOMIC
#ifndef NDEBUG
        ELSE IF (INFO2(2) .LT. 0) THEN
           STOP 'ZHZL2: BIGROT < 0'
#endif
        END IF

        TNS = GET_THREAD_NS()
        CALL ZUPXFER(IAM,BSTEP, MXNC,NCP,NCQ,NCB, M,N,K, Y,YU,LDY, W,WV,LDW, Z,ZZ,LDZ, BZ,LDB,&
             JSCOMM,CPR,NBSTEPS, PSHBUF, LNOROT)
        TNS = GET_THREAD_NS() - TNS
        !$OMP ATOMIC UPDATE
        PSTATS(3) = MAX(PSTATS(3), TNS)
        !$OMP END ATOMIC
        !$OMP BARRIER
     END DO
     !$OMP ATOMIC READ
     INFO2(1) = PSTATS(4)
     !$OMP END ATOMIC
     IF (INFO2(1) .GT. 0) THEN
        !$OMP ATOMIC READ
        INFO2(2) = PSTATS(5)
        !$OMP END ATOMIC
#ifndef NDEBUG
        IF (INFO2(2) .LT. 0) STOP 'ZHZL2: SWEEP BIGROT < 0'
#endif
     ELSE IF (INFO2(1) .EQ. 0) THEN
        INFO2(2) = 0
#ifndef NDEBUG
     ELSE
        STOP 'ZHZL2: SWEEP ALLROT < 0'
#endif
     END IF
     !$OMP MASTER
     WRITE (ULOG,'(A,I4,2(A,I20))') 'Sweep:', BSWP, ' AllRot:', INFO2(1), ' BigRot:', INFO2(2)
     !$OMP END MASTER
     !$OMP BARRIER
     IF (INFO2(1) .GT. 0) THEN
        !$OMP ATOMIC UPDATE
        PSTATS(6) = PSTATS(6) + INFO2(1)
        !$OMP END ATOMIC
        IF (INFO2(2) .GT. 0) THEN
           !$OMP ATOMIC UPDATE
           PSTATS(7) = PSTATS(7) + INFO2(2)
           !$OMP END ATOMIC
        END IF
     END IF
     ! Reset for the next sweep.
     IF (INFO2(2) .GT. 0) THEN
        !$OMP MASTER
        !$OMP ATOMIC WRITE
        PSTATS(4) = 0
        !$OMP END ATOMIC
        !$OMP ATOMIC WRITE
        PSTATS(5) = 0
        !$OMP END ATOMIC
        !$OMP END MASTER
     ELSE IF (INFO2(2) .EQ. 0) THEN
        EXIT
#ifndef NDEBUG
     ELSE
        STOP 'ZHZL2: should never happen'
#endif
     END IF
  END DO

  ! END MAIN LOOP

  !$OMP MASTER
  !$OMP ATOMIC WRITE
  PSTATS(8) = BSWP
  !$OMP END ATOMIC
  !$OMP END MASTER
  INFO = BSWP

  ! Column scaling.

  BSTEP = 1
  P = JSPAIR(1,IAM,BSTEP)
  NCP = NCOLSB(P)
  Q = JSPAIR(2,IAM,BSTEP)
  NCQ = NCOLSB(Q)
  NCB = NCP + NCQ
  IFCP = IFCOLB(P)
  IFCQ = IFCOLB(Q)
  I = 1 + (MXNC - NCP)

#ifndef NDEBUG
  CALL IEEE_SET_HALTING_MODE(IEEE_OVERFLOW, .FALSE._c_int)
#endif

  DO L = 0, NCP-1
     EY(I+L) = D_ZERO
     DO JSINTN = 1, M
        ZTMP = Y(JSINTN,I+L)
        DTMP = REAL(ZTMP)*REAL(ZTMP) + AIMAG(ZTMP)*AIMAG(ZTMP)
        EY(I+L) = EY(I+L) + J(JSINTN) * DTMP
     END DO
     IF (EY(I+L) .NE. D_ZERO) THEN
        DTMP = ABS(EY(I+L))
        IF (DTMP .NE. D_ONE) THEN
           SY(I+L) = SQRT(DTMP)
           DTMP = D_ONE / SY(I+L)
           CALL ZDSCAL(M, DTMP, Y(1,I+L), 1)
        ELSE
           SY(I+L) = D_ONE
        END IF
     ELSE
        SY(I+L) = D_ZERO
     END IF

     SW(I+L) = D_ZERO
     EW(I+L) = D_ONE
     CALL ZLASSQ(M, W(1,I+L), 1, SW(I+L), EW(I+L))
     DTMP = SW(I+L) * SQRT(EW(I+L))
     EW(I+L) = SW(I+L) * (SW(I+L) * EW(I+L))
     SW(I+L) = DTMP
     IF (SW(I+L) .NE. D_ONE) THEN
        DTMP = D_ONE / SW(I+L)
        CALL ZDSCAL(M, DTMP, W(1,I+L), 1)
     END IF

     E(I+L) = EY(I+L) / EW(I+L) 
     SS(I+L) = HYPOT(SY(I+L), SW(I+L))
     IF (SS(I+L) .NE. D_ONE) THEN
        DTMP = D_ONE / SS(I+L)
        SY(I+L) = SY(I+L) * DTMP
        SW(I+L) = SW(I+L) * DTMP
        CALL ZDSCAL(N, DTMP, Z(1,I+L), 1)
     END IF
  END DO

  DO L = 1, NCQ
     EY(MXNC+L) = D_ZERO
     DO JSINTN = 1, M
        ZTMP = Y(JSINTN,MXNC+L)
        DTMP = REAL(ZTMP)*REAL(ZTMP) + AIMAG(ZTMP)*AIMAG(ZTMP)
        EY(MXNC+L) = EY(MXNC+L) + J(JSINTN) * DTMP
     END DO
     IF (EY(MXNC+L) .NE. D_ZERO) THEN
        DTMP = ABS(EY(MXNC+L))
        IF (DTMP .NE. D_ONE) THEN
           SY(MXNC+L) = SQRT(DTMP)
           DTMP = D_ONE / SY(MXNC+L)
           CALL ZDSCAL(M, DTMP, Y(1,MXNC+L), 1)
        ELSE
           SY(MXNC+L) = D_ONE
        END IF
     ELSE
        SY(MXNC+L) = D_ZERO
     END IF

     SW(MXNC+L) = D_ZERO
     EW(MXNC+L) = D_ONE
     CALL ZLASSQ(M, W(1,MXNC+L), 1, SW(MXNC+L), EW(MXNC+L))
     DTMP = SW(MXNC+L) * SQRT(EW(MXNC+L))
     EW(MXNC+L) = SW(MXNC+L) * (SW(MXNC+L) * EW(MXNC+L))
     SW(MXNC+L) = DTMP
     IF (SW(MXNC+L) .NE. D_ONE) THEN
        DTMP = D_ONE / SW(MXNC+L)
        CALL ZDSCAL(M, DTMP, W(1,MXNC+L), 1)
     END IF

     E(MXNC+L) = EY(MXNC+L) / EW(MXNC+L)
     SS(MXNC+L) = HYPOT(SY(MXNC+L), SW(MXNC+L))
     IF (SS(MXNC+L) .NE. D_ONE) THEN
        DTMP = D_ONE / SS(MXNC+L)
        SY(MXNC+L) = SY(MXNC+L) * DTMP
        SW(MXNC+L) = SW(MXNC+L) * DTMP
        CALL ZDSCAL(N, DTMP, Z(1,MXNC+L), 1)
     END IF
  END DO

#ifndef NDEBUG
  DO L = 1, 5
     CALL IEEE_SET_HALTING_MODE(IEEE_ALL(L), LFHALT(L))
  END DO
#endif
END SUBROUTINE ZHZL2
