MODULE PARAMS
#ifndef NDEBUG
  USE, INTRINSIC :: IEEE_ARITHMETIC
  USE, INTRINSIC :: IEEE_FEATURES
#endif
  USE, INTRINSIC :: ISO_C_BINDING
  USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY : INPUT_UNIT, OUTPUT_UNIT, ERROR_UNIT
  IMPLICIT NONE

  INTEGER, PARAMETER :: UINP = INPUT_UNIT
  INTEGER, PARAMETER :: UOUT = OUTPUT_UNIT
  INTEGER, PARAMETER :: ULOG = ERROR_UNIT

  INTEGER, PARAMETER :: LWP = KIND(.FALSE.)
  INTEGER, PARAMETER :: IWP = KIND(0)
#ifdef KIND_SINGLE
  INTEGER, PARAMETER :: SWP = KIND_SINGLE
#else
  INTEGER, PARAMETER :: SWP = KIND(0.0E0)
#endif
#ifdef KIND_DOUBLE
  INTEGER, PARAMETER :: DWP = KIND_DOUBLE
#else
  INTEGER, PARAMETER :: DWP = KIND(0.0D0)
#endif
#ifdef KIND_FILE
  INTEGER, PARAMETER :: FWP = KIND_FILE
#else
  INTEGER, PARAMETER :: FWP = DWP
#endif

  ! Max file name length.
  INTEGER, PARAMETER :: FNL = 252

  ! Cache line size in bytes.
  ! Valid for the Intel CPUs, needs changing for e.g. POWER (128 B).
#ifdef CACHE_LINE_SIZE_B
  INTEGER, PARAMETER :: CLSIZB = CACHE_LINE_SIZE_B
#else
  INTEGER, PARAMETER :: CLSIZB = 64
#endif

  ! Memory page size in bytes (assumed to be a multiple of the cache line size).
  ! A default for the Intel CPUs is used, needs changing for the other architectures.
#ifdef PAGE_SIZE_B
  INTEGER, PARAMETER :: PGSIZB = PAGE_SIZE_B
#else
  INTEGER, PARAMETER :: PGSIZB = 4096
#endif

  ! Max SIMD vector length in bytes.
  ! Valid for the Intel AVX-512, otherwise smaller (but >= 16 B).
#ifdef SIMD_VEC_LEN_B
  INTEGER, PARAMETER :: SIMDLB = SIMD_VEC_LEN_B
#else
  INTEGER, PARAMETER :: SIMDLB = 64
#endif

  ! Alignment in bytes = max(cache line size, vector length)
  INTEGER, PARAMETER :: ALIGNB = MAX(CLSIZB, SIMDLB)

  INTEGER, PARAMETER :: LSIMDL = SIMDLB / LWP
  INTEGER, PARAMETER :: ISIMDL = SIMDLB / IWP
  INTEGER, PARAMETER :: SSIMDL = SIMDLB / (SWP + MOD(SWP,4)*3)
  INTEGER, PARAMETER :: DSIMDL = SIMDLB / (DWP + MOD(DWP,4)*3)
  INTEGER, PARAMETER :: CSIMDL = SSIMDL / 2
  INTEGER, PARAMETER :: ZSIMDL = DSIMDL / 2

  INTEGER, PARAMETER :: LALIGN = ALIGNB / LWP
  INTEGER, PARAMETER :: IALIGN = ALIGNB / IWP
  INTEGER, PARAMETER :: SALIGN = ALIGNB / (SWP + MOD(SWP,4)*3)
  INTEGER, PARAMETER :: DALIGN = ALIGNB / (DWP + MOD(DWP,4)*3)
  INTEGER, PARAMETER :: CALIGN = SALIGN / 2
  INTEGER, PARAMETER :: ZALIGN = DALIGN / 2

#ifdef MAX_CORES_PER_RUN
  INTEGER, PARAMETER :: MAXCPR = MAX_CORES_PER_RUN
#else
  INTEGER, PARAMETER :: MAXCPR = 96 ! max. number of 2nd-level threads
#endif

#ifdef MAX_THREADS_PER_CORE
  INTEGER, PARAMETER :: MAXTPC = MAX_THREADS_PER_CORE
#else
  INTEGER, PARAMETER :: MAXTPC = 64 ! max. number of 1st-level threads
#endif

  REAL(KIND=SWP), PARAMETER :: S_ZERO =  0.0_SWP
  REAL(KIND=SWP), PARAMETER :: S_MZERO= -0.0_SWP
  REAL(KIND=SWP), PARAMETER :: S_ONE  =  1.0_SWP
  REAL(KIND=SWP), PARAMETER :: S_MONE = -1.0_SWP
  REAL(KIND=SWP), PARAMETER :: S_TWO  =  2.0_SWP
  REAL(KIND=SWP), PARAMETER :: S_MTWO = -2.0_SWP

  COMPLEX(KIND=SWP), PARAMETER :: C_ZERO  = (S_ZERO, S_ZERO)
  COMPLEX(KIND=SWP), PARAMETER :: C_ONE   = (S_ONE , S_ZERO)
  COMPLEX(KIND=SWP), PARAMETER :: C_MONE  = (S_MONE, S_ZERO)
  COMPLEX(KIND=SWP), PARAMETER :: C_IONE  = (S_ZERO, S_ONE )
  COMPLEX(KIND=SWP), PARAMETER :: C_MIONE = (S_ZERO, S_MONE)

  REAL(KIND=DWP), PARAMETER :: D_ZERO =  0.0_DWP
  REAL(KIND=DWP), PARAMETER :: D_MZERO= -0.0_DWP
  REAL(KIND=DWP), PARAMETER :: D_ONE  =  1.0_DWP
  REAL(KIND=DWP), PARAMETER :: D_MONE = -1.0_DWP
  REAL(KIND=DWP), PARAMETER :: D_TWO  =  2.0_DWP
  REAL(KIND=DWP), PARAMETER :: D_MTWO = -2.0_DWP

  REAL(KIND=DWP), PARAMETER :: D_CS_PI_4 = SQRT(D_TWO) / D_TWO
  REAL(KIND=DWP), PARAMETER :: D_ALPHA = (D_ONE + SQRT(17.0_DWP)) / 8.0_DWP

  COMPLEX(KIND=DWP), PARAMETER :: Z_ZERO  = (D_ZERO, D_ZERO)
  COMPLEX(KIND=DWP), PARAMETER :: Z_ONE   = (D_ONE , D_ZERO)
  COMPLEX(KIND=DWP), PARAMETER :: Z_MONE  = (D_MONE, D_ZERO)
  COMPLEX(KIND=DWP), PARAMETER :: Z_IONE  = (D_ZERO, D_ONE )
  COMPLEX(KIND=DWP), PARAMETER :: Z_MIONE = (D_ZERO, D_MONE)

  REAL(KIND=SWP), PARAMETER :: S_EPS = EPSILON(S_ONE)
  REAL(KIND=DWP), PARAMETER :: D_EPS = EPSILON(D_ONE)

  INTEGER(KIND=c_int32_t), PARAMETER :: S_QNAN_MASK = 2143289344_c_int32_t
  INTEGER(KIND=c_int64_t), PARAMETER :: D_QNAN_MASK = 9221120237041090560_c_int64_t

  INTERFACE QUIET_NAN
     MODULE PROCEDURE S_QUIET_NAN
     MODULE PROCEDURE D_QUIET_NAN
  END INTERFACE QUIET_NAN

CONTAINS

  PURE FUNCTION S_QUIET_NAN(PAYLOAD)
    IMPLICIT NONE
    INTEGER(KIND=c_int), INTENT(IN) :: PAYLOAD
    REAL(KIND=c_float) :: S_QUIET_NAN
    S_QUIET_NAN = TRANSFER(IOR(PAYLOAD, S_QNAN_MASK), 0.0_c_float)
  END FUNCTION S_QUIET_NAN

  PURE FUNCTION D_QUIET_NAN(PAYLOAD)
    IMPLICIT NONE
    INTEGER(KIND=c_int64_t), INTENT(IN) :: PAYLOAD
    REAL(KIND=c_double) :: D_QUIET_NAN
    D_QUIET_NAN = TRANSFER(IOR(PAYLOAD, D_QNAN_MASK), 0.0_c_double)
  END FUNCTION D_QUIET_NAN

#ifdef NDEBUG
  PURE FUNCTION S_VERIFY_MIN()
#else
  FUNCTION S_VERIFY_MIN()
#endif
    IMPLICIT NONE
    LOGICAL :: S_VERIFY_MIN
#ifndef NDEBUG
    LOGICAL(c_int) :: HM_INV
    CALL IEEE_GET_HALTING_MODE(IEEE_INVALID, HM_INV)
    CALL IEEE_SET_HALTING_MODE(IEEE_INVALID, .FALSE._c_int)
#endif
    S_VERIFY_MIN = (MIN(S_QUIET_NAN(-1_c_int32_t), 0.0_c_float) .EQ. 0.0_c_float)
#ifndef NDEBUG
    CALL IEEE_SET_HALTING_MODE(IEEE_INVALID, HM_INV)
#endif
  END FUNCTION S_VERIFY_MIN

#ifdef NDEBUG
  PURE FUNCTION D_VERIFY_MIN()
#else
  FUNCTION D_VERIFY_MIN()
#endif
    IMPLICIT NONE
    LOGICAL :: D_VERIFY_MIN
#ifndef NDEBUG
    LOGICAL(c_int) :: HM_INV
    CALL IEEE_GET_HALTING_MODE(IEEE_INVALID, HM_INV)
    CALL IEEE_SET_HALTING_MODE(IEEE_INVALID, .FALSE._c_int)
#endif
    D_VERIFY_MIN = (MIN(D_QUIET_NAN(-1_c_int64_t), 0.0_c_double) .EQ. 0.0_c_double)
#ifndef NDEBUG
    CALL IEEE_SET_HALTING_MODE(IEEE_INVALID, HM_INV)
#endif
  END FUNCTION D_VERIFY_MIN

! #ifdef NDEBUG
!   PURE FUNCTION S_VERIFY_MIN()
! #else
!   FUNCTION S_VERIFY_MIN()
! #endif
!     IMPLICIT NONE
!     LOGICAL :: S_VERIFY_MIN
! #ifndef NDEBUG
!     LOGICAL(c_int) :: HM_INV
!     CALL IEEE_GET_HALTING_MODE(IEEE_INVALID, HM_INV)
!     CALL IEEE_SET_HALTING_MODE(IEEE_INVALID, .FALSE._c_int)
! #endif
!     S_VERIFY_MIN = (&
!          (MIN(S_QUIET_NAN(-1_c_int32_t), 0.0_c_float) .EQ. 0.0_c_float) .AND. &
!          (MIN(0.0_c_float, S_QUIET_NAN(-1_c_int32_t)) .EQ. 0.0_c_float))
! #ifndef NDEBUG
!     CALL IEEE_SET_HALTING_MODE(IEEE_INVALID, HM_INV)
! #endif
!   END FUNCTION S_VERIFY_MIN

! #ifdef NDEBUG
!   PURE FUNCTION D_VERIFY_MIN()
! #else
!   FUNCTION D_VERIFY_MIN()
! #endif
!     IMPLICIT NONE
!     LOGICAL :: D_VERIFY_MIN
! #ifndef NDEBUG
!     LOGICAL(c_int) :: HM_INV
!     CALL IEEE_GET_HALTING_MODE(IEEE_INVALID, HM_INV)
!     CALL IEEE_SET_HALTING_MODE(IEEE_INVALID, .FALSE._c_int)
! #endif
!     D_VERIFY_MIN = (&
!          (MIN(D_QUIET_NAN(-1_c_int64_t), 0.0_c_double) .EQ. 0.0_c_double) .AND. &
!          (MIN(0.0_c_double, D_QUIET_NAN(-1_c_int64_t)) .EQ. 0.0_c_double))
! #ifndef NDEBUG
!     CALL IEEE_SET_HALTING_MODE(IEEE_INVALID, HM_INV)
! #endif
!   END FUNCTION D_VERIFY_MIN

#ifdef NDEBUG
  PURE FUNCTION VERIFY_MIN()
#else
  FUNCTION VERIFY_MIN()
#endif
    IMPLICIT NONE
    LOGICAL :: VERIFY_MIN
    VERIFY_MIN = (S_VERIFY_MIN() .AND. D_VERIFY_MIN())
  END FUNCTION VERIFY_MIN

#ifdef NDEBUG
  PURE FUNCTION S_VERIFY_MAX()
#else
  FUNCTION S_VERIFY_MAX()
#endif
    IMPLICIT NONE
    LOGICAL :: S_VERIFY_MAX
#ifndef NDEBUG
    LOGICAL(c_int) :: HM_INV
    CALL IEEE_GET_HALTING_MODE(IEEE_INVALID, HM_INV)
    CALL IEEE_SET_HALTING_MODE(IEEE_INVALID, .FALSE._c_int)
#endif
    S_VERIFY_MAX = (MAX(S_QUIET_NAN(0_c_int32_t), -1.0_c_float) .EQ. -1.0_c_float)
#ifndef NDEBUG
    CALL IEEE_SET_HALTING_MODE(IEEE_INVALID, HM_INV)
#endif
  END FUNCTION S_VERIFY_MAX

#ifdef NDEBUG
  PURE FUNCTION D_VERIFY_MAX()
#else
  FUNCTION D_VERIFY_MAX()
#endif
    IMPLICIT NONE
    LOGICAL :: D_VERIFY_MAX
#ifndef NDEBUG
    LOGICAL(c_int) :: HM_INV
    CALL IEEE_GET_HALTING_MODE(IEEE_INVALID, HM_INV)
    CALL IEEE_SET_HALTING_MODE(IEEE_INVALID, .FALSE._c_int)
#endif
    D_VERIFY_MAX = (MAX(D_QUIET_NAN(0_c_int64_t), -1.0_c_double) .EQ. -1.0_c_double)
#ifndef NDEBUG
    CALL IEEE_SET_HALTING_MODE(IEEE_INVALID, HM_INV)
#endif
  END FUNCTION D_VERIFY_MAX

! #ifdef NDEBUG
!   PURE FUNCTION S_VERIFY_MAX()
! #else
!   FUNCTION S_VERIFY_MAX()
! #endif
!     IMPLICIT NONE
!     LOGICAL :: S_VERIFY_MAX
! #ifndef NDEBUG
!     LOGICAL(c_int) :: HM_INV
!     CALL IEEE_GET_HALTING_MODE(IEEE_INVALID, HM_INV)
!     CALL IEEE_SET_HALTING_MODE(IEEE_INVALID, .FALSE._c_int)
! #endif
!     S_VERIFY_MAX = (&
!          (MAX(S_QUIET_NAN(0_c_int32_t), -1.0_c_float) .EQ. -1.0_c_float) .AND. &
!          (MAX(-1.0_c_float, S_QUIET_NAN(0_c_int32_t)) .EQ. -1.0_c_float))
! #ifndef NDEBUG
!     CALL IEEE_SET_HALTING_MODE(IEEE_INVALID, HM_INV)
! #endif
!   END FUNCTION S_VERIFY_MAX

! #ifdef NDEBUG
!   PURE FUNCTION D_VERIFY_MAX()
! #else
!   FUNCTION D_VERIFY_MAX()
! #endif
!     IMPLICIT NONE
!     LOGICAL :: D_VERIFY_MAX
! #ifndef NDEBUG
!     LOGICAL(c_int) :: HM_INV
!     CALL IEEE_GET_HALTING_MODE(IEEE_INVALID, HM_INV)
!     CALL IEEE_SET_HALTING_MODE(IEEE_INVALID, .FALSE._c_int)
! #endif
!     D_VERIFY_MAX = (&
!          (MAX(D_QUIET_NAN(0_c_int64_t), -1.0_c_double) .EQ. -1.0_c_double) .AND. &
!          (MAX(-1.0_c_double, D_QUIET_NAN(0_c_int64_t)) .EQ. -1.0_c_double))
! #ifndef NDEBUG
!     CALL IEEE_SET_HALTING_MODE(IEEE_INVALID, HM_INV)
! #endif
!   END FUNCTION D_VERIFY_MAX

#ifdef NDEBUG
  PURE FUNCTION VERIFY_MAX()
#else
  FUNCTION VERIFY_MAX()
#endif
    IMPLICIT NONE
    LOGICAL :: VERIFY_MAX
    VERIFY_MAX = (S_VERIFY_MAX() .AND. D_VERIFY_MAX())
  END FUNCTION VERIFY_MAX

#ifdef NDEBUG
  PURE FUNCTION VERIFY_MIN_MAX()
#else
  FUNCTION VERIFY_MIN_MAX()
#endif
    IMPLICIT NONE
    LOGICAL :: VERIFY_MIN_MAX
    VERIFY_MIN_MAX = (VERIFY_MIN() .AND. VERIFY_MAX())
  END FUNCTION VERIFY_MIN_MAX

  PURE FUNCTION LDALIGN(M, TALIGN)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: M, TALIGN
    INTEGER :: LDALIGN, R

    IF (M .LE. TALIGN) THEN
       LDALIGN = TALIGN
    ELSE
       R = MOD(M, TALIGN)
       IF (R .EQ. 0) THEN
          LDALIGN = M
       ELSE
          LDALIGN = M + (TALIGN - R)
       END IF
    END IF
  END FUNCTION LDALIGN
END MODULE PARAMS
