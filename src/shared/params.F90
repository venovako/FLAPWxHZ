MODULE PARAMS
  USE, INTRINSIC :: ISO_C_BINDING
  USE, INTRINSIC :: ISO_FORTRAN_ENV, ONLY : INPUT_UNIT, OUTPUT_UNIT, ERROR_UNIT
  IMPLICIT NONE

  INTEGER, PARAMETER :: UINP = INPUT_UNIT
  INTEGER, PARAMETER :: UOUT = OUTPUT_UNIT
  INTEGER, PARAMETER :: ULOG = ERROR_UNIT

  INTEGER, PARAMETER :: LWP = KIND(.FALSE.)
  INTEGER, PARAMETER :: IWP = KIND(0)

#ifdef KIND_SINGLE
  INTEGER, PARAMETER :: SWP = KIND_SINGLE
#else
  INTEGER, PARAMETER :: SWP = KIND(0.0E0)
#endif
#ifdef KIND_DOUBLE
  INTEGER, PARAMETER :: DWP = KIND_DOUBLE
#else
  INTEGER, PARAMETER :: DWP = KIND(0.0D0)
#endif
#ifdef KIND_FILE
  INTEGER, PARAMETER :: FWP = KIND_FILE
#else
  INTEGER, PARAMETER :: FWP = DWP
#endif

  ! Cache line size in bytes.
  ! Valid for Intel CPUs, needs changing for e.g. POWER (128 B).
#ifdef CACHE_LINE_SIZE_B
  INTEGER, PARAMETER :: CLSIZB = CACHE_LINE_SIZE_B
#else
  INTEGER, PARAMETER :: CLSIZB = 64
#endif

  ! Max SIMD vector length in bytes.
  ! Valid for Intel AVX-512, otherwise smaller (but >= 16 B).
#ifdef SIMD_VEC_LEN_B
  INTEGER, PARAMETER :: SIMDLB = SIMD_VEC_LEN_B
#else
  INTEGER, PARAMETER :: SIMDLB = 64
#endif

  ! Alignment in bytes = max(cache line size, vector length)
  INTEGER, PARAMETER :: ALIGNB = MAX(CLSIZB, SIMDLB)

  ! INTEGER, PARAMETER :: LSIMDL = SIMDLB / SIZEOF(.FALSE.)
  INTEGER, PARAMETER :: LSIMDL = SIMDLB / LWP
  ! INTEGER, PARAMETER :: ISIMDL = SIMDLB / SIZEOF(0)
  INTEGER, PARAMETER :: ISIMDL = SIMDLB / IWP
  ! INTEGER, PARAMETER :: SSIMDL = SIMDLB / SIZEOF(0.0E0)
  INTEGER, PARAMETER :: SSIMDL = SIMDLB / (SWP + MOD(SWP,4)*3)
  ! INTEGER, PARAMETER :: DSIMDL = SIMDLB / SIZEOF(0.0D0)
  INTEGER, PARAMETER :: DSIMDL = SIMDLB / (DWP + MOD(DWP,4)*3)
  INTEGER, PARAMETER :: CSIMDL = SSIMDL / 2
  INTEGER, PARAMETER :: ZSIMDL = DSIMDL / 2

  ! INTEGER, PARAMETER :: LALIGN = ALIGNB / SIZEOF(.FALSE.)
  INTEGER, PARAMETER :: LALIGN = ALIGNB / LWP
  ! INTEGER, PARAMETER :: IALIGN = ALIGNB / SIZEOF(0)
  INTEGER, PARAMETER :: IALIGN = ALIGNB / IWP
  ! INTEGER, PARAMETER :: SALIGN = ALIGNB / SIZEOF(0.0E0)
  INTEGER, PARAMETER :: SALIGN = ALIGNB / (SWP + MOD(SWP,4)*3)
  ! INTEGER, PARAMETER :: DALIGN = ALIGNB / SIZEOF(0.0D0)
  INTEGER, PARAMETER :: DALIGN = ALIGNB / (DWP + MOD(DWP,4)*3)

  INTEGER, PARAMETER :: CALIGN = SALIGN / 2
  INTEGER, PARAMETER :: ZALIGN = DALIGN / 2

#ifdef MAX_CORES_PER_RUN
  INTEGER, PARAMETER :: MAXCPR = MAX_CORES_PER_RUN
#else
  INTEGER, PARAMETER :: MAXCPR = 96 ! max. number of 2nd-level threads
#endif

#ifdef MAX_THREADS_PER_CORE
  INTEGER, PARAMETER :: MAXTPC = MAX_THREADS_PER_CORE
#else
  INTEGER, PARAMETER :: MAXTPC = 64 ! max. number of 1st-level threads
#endif

  REAL, PARAMETER :: S_ZERO  =  0.0E0
  REAL, PARAMETER :: S_ONE   =  1.0E0
  REAL, PARAMETER :: S_MONE  = -1.0E0

  COMPLEX, PARAMETER :: C_ZERO  = (S_ZERO, S_ZERO)
  COMPLEX, PARAMETER :: C_ONE   = (S_ONE , S_ZERO)
  COMPLEX, PARAMETER :: C_MONE  = (S_MONE, S_ZERO)
  COMPLEX, PARAMETER :: C_IONE  = (S_ZERO, S_ONE )
  COMPLEX, PARAMETER :: C_MIONE = (S_ZERO, S_MONE)

  DOUBLE PRECISION, PARAMETER :: D_ZERO =  0.0D0
  DOUBLE PRECISION, PARAMETER :: D_MZERO= -0.0D0
  DOUBLE PRECISION, PARAMETER :: D_ONE  =  1.0D0
  DOUBLE PRECISION, PARAMETER :: D_MONE = -1.0D0
  DOUBLE PRECISION, PARAMETER :: D_TWO  =  2.0D0
  DOUBLE PRECISION, PARAMETER :: D_MTWO = -2.0D0

  DOUBLE COMPLEX, PARAMETER :: Z_ZERO  = (D_ZERO, D_ZERO)
  DOUBLE COMPLEX, PARAMETER :: Z_ONE   = (D_ONE , D_ZERO)
  DOUBLE COMPLEX, PARAMETER :: Z_MONE  = (D_MONE, D_ZERO)
  DOUBLE COMPLEX, PARAMETER :: Z_IONE  = (D_ZERO, D_ONE )
  DOUBLE COMPLEX, PARAMETER :: Z_MIONE = (D_ZERO, D_MONE)

CONTAINS

  PURE INTEGER FUNCTION LDALIGN(M, TALIGN)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: M, TALIGN

    INTEGER :: R

    IF (M .LE. TALIGN) THEN
       LDALIGN = TALIGN
    ELSE
       R = MOD(M, TALIGN)
       IF (R .EQ. 0) THEN
          LDALIGN = M
       ELSE
          LDALIGN = M + (TALIGN - R)
       END IF
    END IF
  END FUNCTION LDALIGN
END MODULE PARAMS
