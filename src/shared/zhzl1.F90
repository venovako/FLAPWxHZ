! L1 double complex HZ.
#ifndef MKL_NEST_SEQ
SUBROUTINE ZHZL1(K, BH,NPLUS, BS,BZ, LDB, JS,JSPAIR, NSWP,TPC, NROT,INFO)
#else
SUBROUTINE ZHZL1(K, BH,NPLUS, BS,BZ, LDB, JS,JSPAIR, NSWP, NROT,INFO)
#endif
#ifndef NDEBUG
  USE, INTRINSIC :: IEEE_ARITHMETIC
  USE, INTRINSIC :: IEEE_FEATURES
#endif
  IMPLICIT NONE

  INTEGER, INTENT(IN) :: K,NPLUS,LDB, JS(8),JSPAIR(2,JS(8),JS(7)), NSWP
#ifndef MKL_NEST_SEQ
  INTEGER, INTENT(IN) :: TPC
#endif
  DOUBLE COMPLEX, INTENT(INOUT) :: BH(LDB,K),BS(LDB,K),BZ(LDB,K)
  INTEGER, INTENT(OUT) :: NROT(2),INFO

  INTEGER :: NSTEPS, NPAIRS
  INTEGER :: PPV, VPS
  INTEGER :: SWEEP, STEP, VEC, PIX, PAIR
  INTEGER :: P, Q, I, J, L
  INTEGER :: SNROT(2)

  DOUBLE PRECISION :: DTOL, DSCL(3)
  !DIR$ ATTRIBUTES ALIGN:ALIGNB :: DTOL

  ! vector variables

  INTEGER :: HZ(ISIMDL)
  DOUBLE PRECISION :: DHZ(DSIMDL)
  !DIR$ ATTRIBUTES ALIGN:ALIGNB :: HZ, DHZ

  DOUBLE PRECISION :: RE_H_PP(DSIMDL)
  DOUBLE PRECISION :: RE_H_QQ(DSIMDL)
  DOUBLE PRECISION :: RE_H_PQ(DSIMDL)
  DOUBLE PRECISION :: IM_H_PQ(DSIMDL)
  DOUBLE PRECISION :: AV_H_PQ(DSIMDL)
  DOUBLE PRECISION :: CA_H_PQ(DSIMDL)
  DOUBLE PRECISION :: SA_H_PQ(DSIMDL)
  !DIR$ ATTRIBUTES ALIGN:ALIGNB :: RE_H_PP,RE_H_QQ,RE_H_PQ,IM_H_PQ, AV_H_PQ,CA_H_PQ,SA_H_PQ

  DOUBLE PRECISION :: RE_S_PP(DSIMDL)
  DOUBLE PRECISION :: RE_S_QQ(DSIMDL)
  DOUBLE PRECISION :: RE_S_PQ(DSIMDL)
  DOUBLE PRECISION :: IM_S_PQ(DSIMDL)
  DOUBLE PRECISION :: AV_S_PQ(DSIMDL)
  DOUBLE PRECISION :: CA_S_PQ(DSIMDL)
  DOUBLE PRECISION :: SA_S_PQ(DSIMDL)  
  !DIR$ ATTRIBUTES ALIGN:ALIGNB :: RE_S_PP,RE_S_QQ,RE_S_PQ,IM_S_PQ, AV_S_PQ,CA_S_PQ,SA_S_PQ

  DOUBLE PRECISION :: T(DSIMDL)
  DOUBLE PRECISION :: U(DSIMDL)
  DOUBLE PRECISION :: V(DSIMDL)
  DOUBLE PRECISION :: E(DSIMDL)
  !DIR$ ATTRIBUTES ALIGN:ALIGNB :: T,U,V,E

  DOUBLE PRECISION :: TG(DSIMDL)
  DOUBLE PRECISION :: CG(DSIMDL)
  DOUBLE PRECISION :: SG(DSIMDL)
  !DIR$ ATTRIBUTES ALIGN:ALIGNB :: TG,CG,SG

  DOUBLE PRECISION :: T2T(DSIMDL)
  DOUBLE PRECISION :: C2T(DSIMDL)
  DOUBLE PRECISION :: S2T(DSIMDL)
  !DIR$ ATTRIBUTES ALIGN:ALIGNB :: T2T,C2T,S2T

  DOUBLE PRECISION :: CPHI(DSIMDL)
  DOUBLE PRECISION :: CPSI(DSIMDL)
  DOUBLE PRECISION :: RE_ASPHI(DSIMDL)
  DOUBLE PRECISION :: IM_ASPHI(DSIMDL)
  DOUBLE PRECISION :: RE_MBSPSI(DSIMDL)
  DOUBLE PRECISION :: IM_MBSPSI(DSIMDL)
  !DIR$ ATTRIBUTES ALIGN:ALIGNB :: CPHI,CPSI, RE_ASPHI,IM_ASPHI, RE_MBSPSI,IM_MBSPSI

  DOUBLE COMPLEX :: ZTMP1(DSIMDL)
  DOUBLE COMPLEX :: ZTMP2(DSIMDL)
  !DIR$ ATTRIBUTES ALIGN:ALIGNB :: ZTMP1,ZTMP2

  DOUBLE PRECISION :: DTMP1(DSIMDL)
  DOUBLE PRECISION :: DTMP2(DSIMDL)
  DOUBLE PRECISION :: DTMP3(DSIMDL)
  DOUBLE PRECISION :: DTMP4(DSIMDL)
  !DIR$ ATTRIBUTES ALIGN:ALIGNB :: DTMP1,DTMP2,DTMP3,DTMP4

  DOUBLE PRECISION, EXTERNAL :: DZNRM2
  EXTERNAL :: ZDSCAL

  !DIR$ ASSUME_ALIGNED JS:ALIGNB
  !DIR$ ASSUME_ALIGNED JSPAIR:ALIGNB
  !DIR$ ASSUME_ALIGNED BH:ALIGNB
  !DIR$ ASSUME_ALIGNED BS:ALIGNB
  !DIR$ ASSUME_ALIGNED BZ:ALIGNB
#ifdef NDEBUG
  !DIR$ ASSUME (K .GE. 0)
  !DIR$ ASSUME (MOD(K,2) .EQ. 0)
  !DIR$ ASSUME (NPLUS .GE. 0)
  !DIR$ ASSUME (NPLUS .LE. K)
  !DIR$ ASSUME (MOD(LDB,ZALIGN) .EQ. 0)
  !DIR$ ASSUME (NSWP .GE. 0)
#ifndef MKL_NEST_SEQ
  !DIR$ ASSUME (TPC .GE. 1)
#endif
#else
  IF (K .LT. 0) STOP 'ZHZL1: K .LT. 0'
  IF (MOD(K,2) .NE. 0) STOP 'ZHZL1: MOD(K,2) .NE. 0'
  IF (NPLUS .LT. 0) STOP 'ZHZL1: NPLUS .LT. 0'
  IF (NPLUS .GT. K) STOP 'ZHZL1: NPLUS .GT. K'
  IF (MOD(LDB,ZALIGN) .NE. 0) STOP 'ZHZL1: MOD(LDB,ZALIGN) .NE. 0'
  IF (NSWP .LT. 0) STOP 'ZHZL1: NSWP .LT. 0'
#ifndef MKL_NEST_SEQ
  IF (TPC .LT. 1) STOP 'ZHZL1: TPC .LT. 1'
#endif
#endif

  INFO = 0
  NROT = 0
  IF (K .LE. 0) RETURN

#ifndef NDEBUG
  CALL IEEE_SET_HALTING_MODE(IEEE_OVERFLOW, .FALSE._c_int)
  CALL IEEE_SET_HALTING_MODE(IEEE_DIVIDE_BY_ZERO, .FALSE._c_int)
  CALL IEEE_SET_HALTING_MODE(IEEE_INVALID, .FALSE._c_int)
#endif

  DTOL = SCALE(SQRT(DBLE(K)), -53)

  NSTEPS = JS(7)
  NPAIRS = JS(8)
  ! pairs per vector
  PPV = MIN(NPAIRS, DSIMDL)
  ! vectors per step
  VPS = (NPAIRS + (PPV - 1)) / PPV

  DO SWEEP = 1, NSWP
     SNROT = 0
     DO STEP = 1, NSTEPS
#ifndef MKL_NEST_SEQ
        !$OMP  PARALLEL DO DEFAULT(NONE) NUM_THREADS(TPC) PROC_BIND(CLOSE)               &
        !$OMP& SHARED(JSPAIR,NPAIRS,STEP,PPV,VPS,BH,BS,K,NPLUS,DTOL)                     &
        !$OMP& PRIVATE(VEC,PIX,PAIR, P,Q, I,J,L, DSCL,                                   &
        !$OMP& RE_H_PP,RE_H_QQ,RE_H_PQ,IM_H_PQ, RE_S_PP,RE_S_QQ,RE_S_PQ,IM_S_PQ,         &
        !$OMP& HZ,DHZ, AV_H_PQ,CA_H_PQ,SA_H_PQ, AV_S_PQ,CA_S_PQ,SA_S_PQ, T,U,V,E,        &
        !$OMP& TG,CG,SG, T2T,C2T,S2T, CPHI,CPSI, RE_ASPHI,IM_ASPHI, RE_MBSPSI,IM_MBSPSI, &
        !$OMP& ZTMP1,ZTMP2, DTMP1,DTMP2,DTMP3,DTMP4) REDUCTION(+:SNROT)
#endif
        DO VEC = 1, VPS
#include "zhzl1_def.F90"
           ! compute the dot products
           DO PIX = 1, PPV
              ! ``global'' pair index
              PAIR = (VEC - 1) * PPV + PIX
              IF (PAIR .LE. NPAIRS) THEN
                 P = JSPAIR(1,PAIR,STEP)
                 Q = JSPAIR(2,PAIR,STEP)
                 ! ...dot products...
#include "zhzl1_dps.F90"
#include "zhzl1_dph.F90"
              END IF
           END DO
#include "zhzl1_fhz.F90"
           ! apply the transformations
           DO PIX = 1, PPV
              IF (HZ(PIX) .EQ. 0) CYCLE
              IF (DHZ(PIX) .GT. D_ZERO) SNROT(2) = SNROT(2) + 1
              ! ``global'' pair index
              PAIR = (VEC - 1) * PPV + PIX
              IF (PAIR .LE. NPAIRS) THEN
                 P = JSPAIR(1,PAIR,STEP)
                 Q = JSPAIR(2,PAIR,STEP)
                 ! ...transform...
                 IF (.NOT. (CPHI(PIX) .LE. HUGE(D_ZERO))) STOP 'ZHZL1: F_11 overflow or NaN.'
                 DTMP1(PIX) = CPHI(PIX)
                 IF (.NOT. (ABS(RE_MBSPSI(PIX)) .LE. HUGE(D_ZERO))) STOP 'ZHZL1: |Re(F_21)| overflow or NaN.'
                 IF (.NOT. (ABS(IM_MBSPSI(PIX)) .LE. HUGE(D_ZERO))) STOP 'ZHZL1: |Im(F_21)| overflow or NaN.'
                 ZTMP1(PIX) = DCMPLX(RE_MBSPSI(PIX), IM_MBSPSI(PIX))
                 IF (.NOT. (ABS(RE_ASPHI(PIX)) .LE. HUGE(D_ZERO))) STOP 'ZHZL1: |Re(F_12)| overflow or NaN.'
                 IF (.NOT. (ABS(IM_ASPHI(PIX)) .LE. HUGE(D_ZERO))) STOP 'ZHZL1: |Im(F_12)| overflow or NaN.'
                 ZTMP2(PIX) = DCMPLX(RE_ASPHI(PIX), IM_ASPHI(PIX))
                 IF (.NOT. (CPSI(PIX) .LE. HUGE(D_ZERO))) STOP 'ZHZL1: F_22 overflow or NaN.'
                 DTMP2(PIX) = CPSI(PIX)
                 ! CALL BLAS_ZROTM('R', K, BH(1,P), 1, BH(1,Q), 1, DTMP1(PIX), ZTMP1(PIX), ZTMP2(PIX), DTMP2(PIX), L)
                 ! CALL BLAS_ZROTM('R', K, BS(1,P), 1, BS(1,Q), 1, DTMP1(PIX), ZTMP1(PIX), ZTMP2(PIX), DTMP2(PIX), L)
                 ! CALL BLAS_ZROTM('R', K, BZ(1,P), 1, BZ(1,Q), 1, DTMP1(PIX), ZTMP1(PIX), ZTMP2(PIX), DTMP2(PIX), L)
                 CALL BLAS_ZVROTM(K, BH(1,P), BH(1,Q), DTMP1(PIX), ZTMP1(PIX), ZTMP2(PIX), DTMP2(PIX))
                 CALL BLAS_ZVROTM(K, BS(1,P), BS(1,Q), DTMP1(PIX), ZTMP1(PIX), ZTMP2(PIX), DTMP2(PIX))
                 CALL BLAS_ZVROTM(K, BZ(1,P), BZ(1,Q), DTMP1(PIX), ZTMP1(PIX), ZTMP2(PIX), DTMP2(PIX))
              END IF
           END DO
        END DO
#ifndef MKL_NEST_SEQ
        !$OMP END PARALLEL DO
#endif
     END DO
     IF (SNROT(1) .EQ. 0) EXIT
     NROT(1) = NROT(1) + SNROT(1)
     NROT(2) = NROT(2) + SNROT(2)
  END DO

  INFO = SWEEP

#ifndef MKL_NEST_SEQ
  L = BLAS_SET_NUM_THREADS(1)
#endif
  ! Scaling of Z.
  IF (NROT(1) .GT. 0) THEN
#ifndef MKL_NEST_SEQ
     !$OMP PARALLEL DO DEFAULT(NONE) NUM_THREADS(TPC) PROC_BIND(CLOSE) SHARED(BH,BS,BZ,K) PRIVATE(I,J,DSCL)
#endif
     DO J = 1, K
        DSCL(1) = DZNRM2(K, BH(1,J), 1)
        DSCL(2) = DZNRM2(K, BS(1,J), 1)
        DSCL(3) = HYPOT(DSCL(1), DSCL(2))
        IF (DSCL(3) .NE. D_ONE) THEN
           ! underflow
           IF (DSCL(3) .LT. TINY(D_ZERO)) STOP 'ZHZL1: Scale of Z underflow.'
           ! overflow
           IF (DSCL(3) .GT. HUGE(D_ZERO)) STOP 'ZHZL1: Scale of Z overflow.'
           DTOL = D_ONE / DSCL(3)
           IF (DTOL .LT. TINY(D_ZERO)) THEN
              ! underflow
              DTOL = DSCL(3)
              !DIR$ VECTOR ALWAYS ASSERT,ALIGNED
              DO I = 1, K
                 BZ(I,J) = BZ(I,J) / DTOL
              END DO
           ELSE
              CALL ZDSCAL(K, DTOL, BZ(1,J), 1)
           END IF
        END IF
     END DO
#ifndef MKL_NEST_SEQ
     !$OMP END PARALLEL DO
#endif
  END IF
#ifndef MKL_NEST_SEQ
  L = BLAS_SET_NUM_THREADS(L)
#endif

#ifndef NDEBUG
  CALL IEEE_SET_HALTING_MODE(IEEE_INVALID, .TRUE._c_int)
  CALL IEEE_SET_HALTING_MODE(IEEE_DIVIDE_BY_ZERO, .TRUE._c_int)
  CALL IEEE_SET_HALTING_MODE(IEEE_OVERFLOW, .TRUE._c_int)
#endif
END SUBROUTINE ZHZL1
