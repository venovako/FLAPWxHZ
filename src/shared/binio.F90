MODULE BINIO
  USE PARAMS
  USE VN_BINIO
  IMPLICIT NONE

CONTAINS
  ! _RO: read-only, _RW: read-write, _WO: overwrite
  
  SUBROUTINE BOPEN_RO(FN, SZ, FD)
    IMPLICIT NONE
    CHARACTER(LEN=*,KIND=c_char), INTENT(IN) :: FN
    INTEGER, INTENT(OUT) :: SZ, FD

    INTEGER(KIND=c_size_t) :: C_SZ

    FD = INT(VN_BOPEN_RO((TRIM(FN)//c_null_char), C_SZ))
    SZ = INT(C_SZ)
  END SUBROUTINE BOPEN_RO

  SUBROUTINE BOPEN_RW(FN, SZ, FD)
    IMPLICIT NONE
    CHARACTER(LEN=*,KIND=c_char), INTENT(IN) :: FN
    INTEGER, INTENT(INOUT) :: SZ
    INTEGER, INTENT(OUT) :: FD

    INTEGER(KIND=c_size_t) :: C_SZ

    C_SZ = INT(SZ, c_size_t)
    FD = INT(VN_BOPEN_RW((TRIM(FN)//c_null_char), C_SZ))
    SZ = INT(C_SZ)
  END SUBROUTINE BOPEN_RW

  SUBROUTINE BOPEN_WO(FN, SZ, FD)
    IMPLICIT NONE
    CHARACTER(LEN=*,KIND=c_char), INTENT(IN) :: FN
    INTEGER, INTENT(OUT) :: SZ, FD

    SZ = -1
    CALL BOPEN_RW(FN, SZ, FD)
  END SUBROUTINE BOPEN_WO

  INTEGER FUNCTION BWRITE(FD, BUF, nB, OFF)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: FD, nB, OFF
    TYPE(c_ptr), INTENT(IN) :: BUF
    BWRITE = INT(VN_BWRITE(INT(FD,c_int), BUF, INT(nB,c_size_t), INT(OFF,c_size_t)))
  END FUNCTION BWRITE

  INTEGER FUNCTION BREAD(FD, BUF, nB, OFF)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: FD, nB, OFF
    TYPE(c_ptr), INTENT(IN) :: BUF
    BREAD = INT(VN_BREAD(INT(FD,c_int), BUF, INT(nB,c_size_t), INT(OFF,c_size_t)))
  END FUNCTION BREAD

  SUBROUTINE BCLOSE(FD)
    IMPLICIT NONE
    INTEGER, INTENT(INOUT) :: FD
    IF (FD .GE. 0) FD = INT(VN_BCLOSE(INT(FD,c_int)))
  END SUBROUTINE BCLOSE

  SUBROUTINE BCLOSEN(FD, N)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: N
    INTEGER, INTENT(INOUT) :: FD(N)

    INTEGER :: I

    DO I = N, 1, -1
       CALL BCLOSE(FD(I))
    END DO
  END SUBROUTINE BCLOSEN

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! *_RO routines                                                               !
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  SUBROUTINE BOPEN_X_RO(FN, SZ, FD)
    IMPLICIT NONE
    CHARACTER(LEN=*,KIND=c_char), INTENT(IN) :: FN
    INTEGER, INTENT(OUT) :: SZ, FD
    CALL BOPEN_RO((TRIM(FN)//c_char_'.X'), SZ, FD)
  END SUBROUTINE BOPEN_X_RO

  SUBROUTINE BOPEN_T_RO(FN, SZ, FD)
    IMPLICIT NONE
    CHARACTER(LEN=*,KIND=c_char), INTENT(IN) :: FN
    INTEGER, INTENT(OUT) :: SZ, FD
    CALL BOPEN_RO((TRIM(FN)//c_char_'.T'), SZ, FD)
  END SUBROUTINE BOPEN_T_RO

  SUBROUTINE BOPEN_U_RO(FN, SZ, FD)
    IMPLICIT NONE
    CHARACTER(LEN=*,KIND=c_char), INTENT(IN) :: FN
    INTEGER, INTENT(OUT) :: SZ, FD
    CALL BOPEN_RO((TRIM(FN)//c_char_'.U'), SZ, FD)
  END SUBROUTINE BOPEN_U_RO

  SUBROUTINE BOPEN_J_RO(FN, SZ, FD)
    IMPLICIT NONE
    CHARACTER(LEN=*,KIND=c_char), INTENT(IN) :: FN
    INTEGER, INTENT(OUT) :: SZ, FD
    CALL BOPEN_RO((TRIM(FN)//c_char_'.J'), SZ, FD)
  END SUBROUTINE BOPEN_J_RO

  SUBROUTINE BOPEN_Y_RO(FN, SZ, FD)
    IMPLICIT NONE
    CHARACTER(LEN=*,KIND=c_char), INTENT(IN) :: FN
    INTEGER, INTENT(OUT) :: SZ, FD
    CALL BOPEN_RO((TRIM(FN)//c_char_'.Y'), SZ, FD)
  END SUBROUTINE BOPEN_Y_RO

  SUBROUTINE BOPEN_YU_RO(FN, SZ, FD)
    IMPLICIT NONE
    CHARACTER(LEN=*,KIND=c_char), INTENT(IN) :: FN
    INTEGER, INTENT(OUT) :: SZ, FD
    CALL BOPEN_RO((TRIM(FN)//c_char_'.YU'), SZ, FD)
  END SUBROUTINE BOPEN_YU_RO

  SUBROUTINE BOPEN_SY_RO(FN, SZ, FD)
    IMPLICIT NONE
    CHARACTER(LEN=*,KIND=c_char), INTENT(IN) :: FN
    INTEGER, INTENT(OUT) :: SZ, FD
    CALL BOPEN_RO((TRIM(FN)//c_char_'.SY'), SZ, FD)
  END SUBROUTINE BOPEN_SY_RO

  SUBROUTINE BOPEN_EY_RO(FN, SZ, FD)
    IMPLICIT NONE
    CHARACTER(LEN=*,KIND=c_char), INTENT(IN) :: FN
    INTEGER, INTENT(OUT) :: SZ, FD
    CALL BOPEN_RO((TRIM(FN)//c_char_'.EY'), SZ, FD)
  END SUBROUTINE BOPEN_EY_RO

  SUBROUTINE BOPEN_W_RO(FN, SZ, FD)
    IMPLICIT NONE
    CHARACTER(LEN=*,KIND=c_char), INTENT(IN) :: FN
    INTEGER, INTENT(OUT) :: SZ, FD
    CALL BOPEN_RO((TRIM(FN)//c_char_'.W'), SZ, FD)
  END SUBROUTINE BOPEN_W_RO

  SUBROUTINE BOPEN_WV_RO(FN, SZ, FD)
    IMPLICIT NONE
    CHARACTER(LEN=*,KIND=c_char), INTENT(IN) :: FN
    INTEGER, INTENT(OUT) :: SZ, FD
    CALL BOPEN_RO((TRIM(FN)//c_char_'.WV'), SZ, FD)
  END SUBROUTINE BOPEN_WV_RO

  SUBROUTINE BOPEN_SW_RO(FN, SZ, FD)
    IMPLICIT NONE
    CHARACTER(LEN=*,KIND=c_char), INTENT(IN) :: FN
    INTEGER, INTENT(OUT) :: SZ, FD
    CALL BOPEN_RO((TRIM(FN)//c_char_'.SW'), SZ, FD)
  END SUBROUTINE BOPEN_SW_RO

  SUBROUTINE BOPEN_EW_RO(FN, SZ, FD)
    IMPLICIT NONE
    CHARACTER(LEN=*,KIND=c_char), INTENT(IN) :: FN
    INTEGER, INTENT(OUT) :: SZ, FD
    CALL BOPEN_RO((TRIM(FN)//c_char_'.EW'), SZ, FD)
  END SUBROUTINE BOPEN_EW_RO

  SUBROUTINE BOPEN_Z_RO(FN, SZ, FD)
    IMPLICIT NONE
    CHARACTER(LEN=*,KIND=c_char), INTENT(IN) :: FN
    INTEGER, INTENT(OUT) :: SZ, FD
    CALL BOPEN_RO((TRIM(FN)//c_char_'.Z'), SZ, FD)
  END SUBROUTINE BOPEN_Z_RO

  SUBROUTINE BOPEN_E_RO(FN, SZ, FD)
    IMPLICIT NONE
    CHARACTER(LEN=*,KIND=c_char), INTENT(IN) :: FN
    INTEGER, INTENT(OUT) :: SZ, FD
    CALL BOPEN_RO((TRIM(FN)//c_char_'.E'), SZ, FD)
  END SUBROUTINE BOPEN_E_RO

  SUBROUTINE BOPEN_SS_RO(FN, SZ, FD)
    IMPLICIT NONE
    CHARACTER(LEN=*,KIND=c_char), INTENT(IN) :: FN
    INTEGER, INTENT(OUT) :: SZ, FD
    CALL BOPEN_RO((TRIM(FN)//c_char_'.SS'), SZ, FD)
  END SUBROUTINE BOPEN_SS_RO

  SUBROUTINE BOPEN_ZZ_RO(FN, SZ, FD)
    IMPLICIT NONE
    CHARACTER(LEN=*,KIND=c_char), INTENT(IN) :: FN
    INTEGER, INTENT(OUT) :: SZ, FD
    CALL BOPEN_RO((TRIM(FN)//c_char_'.ZZ'), SZ, FD)
  END SUBROUTINE BOPEN_ZZ_RO

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! *_RW routines                                                               !
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  SUBROUTINE BOPEN_J_RW(FN, SZ, FD)
    IMPLICIT NONE
    CHARACTER(LEN=*,KIND=c_char), INTENT(IN) :: FN
    INTEGER, INTENT(INOUT) :: SZ
    INTEGER, INTENT(OUT) :: FD
    CALL BOPEN_RW((TRIM(FN)//c_char_'.J'), SZ, FD)
  END SUBROUTINE BOPEN_J_RW

  SUBROUTINE BOPEN_Y_RW(FN, SZ, FD)
    IMPLICIT NONE
    CHARACTER(LEN=*,KIND=c_char), INTENT(IN) :: FN
    INTEGER, INTENT(INOUT) :: SZ
    INTEGER, INTENT(OUT) :: FD
    CALL BOPEN_RW((TRIM(FN)//c_char_'.Y'), SZ, FD)
  END SUBROUTINE BOPEN_Y_RW

  SUBROUTINE BOPEN_W_RW(FN, SZ, FD)
    IMPLICIT NONE
    CHARACTER(LEN=*,KIND=c_char), INTENT(IN) :: FN
    INTEGER, INTENT(INOUT) :: SZ
    INTEGER, INTENT(OUT) :: FD
    CALL BOPEN_RW((TRIM(FN)//c_char_'.W'), SZ, FD)
  END SUBROUTINE BOPEN_W_RW

  SUBROUTINE BOPEN_E_RW(FN, SZ, FD)
    IMPLICIT NONE
    CHARACTER(LEN=*,KIND=c_char), INTENT(IN) :: FN
    INTEGER, INTENT(INOUT) :: SZ
    INTEGER, INTENT(OUT) :: FD
    CALL BOPEN_RW((TRIM(FN)//c_char_'.E'), SZ, FD)
  END SUBROUTINE BOPEN_E_RW

  SUBROUTINE BOPEN_Z_RW(FN, SZ, FD)
    IMPLICIT NONE
    CHARACTER(LEN=*,KIND=c_char), INTENT(IN) :: FN
    INTEGER, INTENT(INOUT) :: SZ
    INTEGER, INTENT(OUT) :: FD
    CALL BOPEN_RW((TRIM(FN)//c_char_'.Z'), SZ, FD)
  END SUBROUTINE BOPEN_Z_RW

  SUBROUTINE BOPEN_SS_RW(FN, SZ, FD)
    IMPLICIT NONE
    CHARACTER(LEN=*,KIND=c_char), INTENT(IN) :: FN
    INTEGER, INTENT(INOUT) :: SZ
    INTEGER, INTENT(OUT) :: FD
    CALL BOPEN_RW((TRIM(FN)//c_char_'.SS'), SZ, FD)
  END SUBROUTINE BOPEN_SS_RW

  SUBROUTINE BOPEN_YU_RW(FN, SZ, FD)
    IMPLICIT NONE
    CHARACTER(LEN=*,KIND=c_char), INTENT(IN) :: FN
    INTEGER, INTENT(INOUT) :: SZ
    INTEGER, INTENT(OUT) :: FD
    CALL BOPEN_RW((TRIM(FN)//c_char_'.YU'), SZ, FD)
  END SUBROUTINE BOPEN_YU_RW

  SUBROUTINE BOPEN_EY_RW(FN, SZ, FD)
    IMPLICIT NONE
    CHARACTER(LEN=*,KIND=c_char), INTENT(IN) :: FN
    INTEGER, INTENT(INOUT) :: SZ
    INTEGER, INTENT(OUT) :: FD
    CALL BOPEN_RW((TRIM(FN)//c_char_'.EY'), SZ, FD)
  END SUBROUTINE BOPEN_EY_RW

  SUBROUTINE BOPEN_SY_RW(FN, SZ, FD)
    IMPLICIT NONE
    CHARACTER(LEN=*,KIND=c_char), INTENT(IN) :: FN
    INTEGER, INTENT(INOUT) :: SZ
    INTEGER, INTENT(OUT) :: FD
    CALL BOPEN_RW((TRIM(FN)//c_char_'.SY'), SZ, FD)
  END SUBROUTINE BOPEN_SY_RW

  SUBROUTINE BOPEN_WV_RW(FN, SZ, FD)
    IMPLICIT NONE
    CHARACTER(LEN=*,KIND=c_char), INTENT(IN) :: FN
    INTEGER, INTENT(INOUT) :: SZ
    INTEGER, INTENT(OUT) :: FD
    CALL BOPEN_RW((TRIM(FN)//c_char_'.WV'), SZ, FD)
  END SUBROUTINE BOPEN_WV_RW

  SUBROUTINE BOPEN_EW_RW(FN, SZ, FD)
    IMPLICIT NONE
    CHARACTER(LEN=*,KIND=c_char), INTENT(IN) :: FN
    INTEGER, INTENT(INOUT) :: SZ
    INTEGER, INTENT(OUT) :: FD
    CALL BOPEN_RW((TRIM(FN)//c_char_'.EW'), SZ, FD)
  END SUBROUTINE BOPEN_EW_RW

  SUBROUTINE BOPEN_SW_RW(FN, SZ, FD)
    IMPLICIT NONE
    CHARACTER(LEN=*,KIND=c_char), INTENT(IN) :: FN
    INTEGER, INTENT(INOUT) :: SZ
    INTEGER, INTENT(OUT) :: FD
    CALL BOPEN_RW((TRIM(FN)//c_char_'.SW'), SZ, FD)
  END SUBROUTINE BOPEN_SW_RW

  SUBROUTINE BOPEN_ZZ_RW(FN, SZ, FD)
    IMPLICIT NONE
    CHARACTER(LEN=*,KIND=c_char), INTENT(IN) :: FN
    INTEGER, INTENT(INOUT) :: SZ
    INTEGER, INTENT(OUT) :: FD
    CALL BOPEN_RW((TRIM(FN)//c_char_'.ZZ'), SZ, FD)
  END SUBROUTINE BOPEN_ZZ_RW

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! combined *_RO routines                                                      !
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  SUBROUTINE BOPEN_XTU_RO(FN, L, a, G, SZ, FD, INFO)
    IMPLICIT NONE
    CHARACTER(LEN=*,KIND=c_char), INTENT(IN) :: FN
    INTEGER, INTENT(IN) :: L, a, G
    INTEGER, INTENT(OUT) :: SZ(3), FD(3), INFO

    INTEGER :: EXPTSZ(3), DIFFSZ(3)

    SZ = -1
    FD = -1

    INFO = 0
    IF (G .LT. 0) INFO = -4
    IF (a .LT. 0) INFO = -3
    IF (L .LT. 0) INFO = -2
    IF (INFO .NE. 0) RETURN

    EXPTSZ(1) = (2 * L) * (G)     * a * C_SIZEOF(Z_ZERO)
    EXPTSZ(2) = (2 * L) * (2 * L) * a * C_SIZEOF(Z_ZERO)
    EXPTSZ(3) = (L)               * a * C_SIZEOF(D_ZERO)

    DIFFSZ = 0

    CALL BOPEN_X_RO(FN, SZ(1), FD(1))
    IF (FD(1) .LT. 0) THEN
       INFO = 1
       GOTO 1
    END IF
    DIFFSZ(1) = SZ(1) - EXPTSZ(1)
    IF (DIFFSZ(1) .NE. 0) THEN
       INFO = 1
       GOTO 1
    END IF
 
    CALL BOPEN_T_RO(FN, SZ(2), FD(2))
    IF (FD(2) .LT. 0) THEN
       INFO = 2
       GOTO 1
    END IF
    DIFFSZ(2) = SZ(2) - EXPTSZ(2)
    IF (DIFFSZ(2) .NE. 0) THEN
       INFO = 2
       GOTO 1
    END IF

    CALL BOPEN_U_RO(FN, SZ(3), FD(3))
    IF (FD(3) .LT. 0) THEN
       INFO = 3
       GOTO 1
    END IF
    DIFFSZ(3) = SZ(3) - EXPTSZ(3)
    IF (DIFFSZ(3) .NE. 0) THEN
       INFO = 3
       GOTO 1
    END IF

    RETURN

1   SZ = DIFFSZ
  END SUBROUTINE BOPEN_XTU_RO

  SUBROUTINE BOPEN_YWJ_RO(FN, L, a, G, SZ, FD, INFO)
    IMPLICIT NONE
    CHARACTER(LEN=*,KIND=c_char), INTENT(IN) :: FN
    INTEGER, INTENT(IN) :: L, a, G
    INTEGER, INTENT(OUT) :: SZ(3), FD(3), INFO

    INTEGER :: EXPTSZ(3), DIFFSZ(3)

    SZ = -1
    FD = -1

    INFO = 0
    IF (G .LT. 0) INFO = -4
    IF (a .LT. 0) INFO = -3
    IF (L .LT. 0) INFO = -2
    IF (INFO .NE. 0) RETURN

    EXPTSZ(1) = (2 * L) * (G) * a * C_SIZEOF(Z_ZERO)
    EXPTSZ(2) = (2 * L) * (G) * a * C_SIZEOF(Z_ZERO)
    EXPTSZ(3) = (2 * L)       * a * C_SIZEOF(0)

    DIFFSZ = 0

    CALL BOPEN_Y_RO(FN, SZ(1), FD(1))
    IF (FD(1) .LT. 0) THEN
       INFO = 1
       GOTO 2
    END IF
    DIFFSZ(1) = SZ(1) - EXPTSZ(1)
    IF (DIFFSZ(1) .NE. 0) THEN
       INFO = 1
       GOTO 2
    END IF
 
    CALL BOPEN_W_RO(FN, SZ(2), FD(2))
    IF (FD(2) .LT. 0) THEN
       INFO = 2
       GOTO 2
    END IF
    DIFFSZ(2) = SZ(2) - EXPTSZ(2)
    IF (DIFFSZ(2) .NE. 0) THEN
       INFO = 2
       GOTO 2
    END IF

    CALL BOPEN_J_RO(FN, SZ(3), FD(3))
    IF (FD(3) .LT. 0) THEN
       INFO = 3
       GOTO 2
    END IF
    DIFFSZ(3) = SZ(3) - EXPTSZ(3)
    IF (DIFFSZ(3) .NE. 0) THEN
       INFO = 3
       GOTO 2
    END IF

    RETURN

2   SZ = DIFFSZ
  END SUBROUTINE BOPEN_YWJ_RO

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! combined *_RW routines                                                      !
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  SUBROUTINE BOPEN_YWJ_RW(FN, L, a, G, SZ, FD, INFO)
    IMPLICIT NONE
    CHARACTER(LEN=*,KIND=c_char), INTENT(IN) :: FN
    INTEGER, INTENT(IN) :: L, a, G
    INTEGER, INTENT(OUT) :: SZ(3), FD(3), INFO

    SZ = -1
    FD = -1

    INFO = 0
    IF (G .LT. 0) INFO = -4
    IF (a .LT. 0) INFO = -3
    IF (L .LT. 0) INFO = -2
    IF (INFO .NE. 0) RETURN

    SZ(1) = (2 * L) * (G) * a * C_SIZEOF(Z_ZERO)
    SZ(2) = (2 * L) * (G) * a * C_SIZEOF(Z_ZERO)
    SZ(3) = (2 * L)       * a * C_SIZEOF(0)

    CALL BOPEN_Y_RW(FN, SZ(1), FD(1))
    IF (FD(1) .LT. 0) THEN
       INFO = 1
       RETURN
    END IF

    CALL BOPEN_W_RW(FN, SZ(2), FD(2))
    IF (FD(2) .LT. 0) THEN
       INFO = 2
       RETURN
    END IF

    CALL BOPEN_J_RW(FN, SZ(3), FD(3))
    IF (FD(3) .LT. 0) THEN
       INFO = 3
       RETURN
    END IF
  END SUBROUTINE BOPEN_YWJ_RW

  SUBROUTINE BOPEN_EZS_RW(FN, L, a, G, SZ, FD, INFO)
    IMPLICIT NONE
    CHARACTER(LEN=*,KIND=c_char), INTENT(IN) :: FN
    INTEGER, INTENT(IN) :: L, a, G
    INTEGER, INTENT(OUT) :: SZ(9), FD(9), INFO

    SZ = -1
    FD = -1

    INFO = 0
    IF (G .LT. 0) INFO = -4
    IF (a .LT. 0) INFO = -3
    IF (L .LT. 0) INFO = -2
    IF (INFO .NE. 0) RETURN

    SZ(1) = G * C_SIZEOF(D_ZERO)                 !  E
    SZ(2) = G * G * C_SIZEOF(Z_ZERO)             !  Z

    SZ(3) = G * C_SIZEOF(D_ZERO)                 ! SS
    SZ(4) = (2 * L) * (G) * a * C_SIZEOF(Z_ZERO) ! YU
    SZ(5) = G * C_SIZEOF(D_ZERO)                 ! EY
    SZ(6) = G * C_SIZEOF(D_ZERO)                 ! SY
    SZ(7) = (2 * L) * (G) * a * C_SIZEOF(Z_ZERO) ! WV
    SZ(8) = G * C_SIZEOF(D_ZERO)                 ! EW
    SZ(9) = G * C_SIZEOF(D_ZERO)                 ! SW

    CALL BOPEN_E_RW(FN, SZ(1), FD(1))
    IF (FD(1) .LT. 0) THEN
       INFO = 1
       RETURN
    END IF

    CALL BOPEN_Z_RW(FN, SZ(2), FD(2))
    IF (FD(2) .LT. 0) THEN
       INFO = 2
       RETURN
    END IF

    CALL BOPEN_SS_RW(FN, SZ(3), FD(3))
    IF (FD(3) .LT. 0) THEN
       INFO = 3
       RETURN
    END IF

    CALL BOPEN_YU_RW(FN, SZ(4), FD(4))
    IF (FD(4) .LT. 0) THEN
       INFO = 4
       RETURN
    END IF

    CALL BOPEN_EY_RW(FN, SZ(5), FD(5))
    IF (FD(5) .LT. 0) THEN
       INFO = 5
       RETURN
    END IF

    CALL BOPEN_SY_RW(FN, SZ(6), FD(6))
    IF (FD(6) .LT. 0) THEN
       INFO = 6
       RETURN
    END IF

    CALL BOPEN_WV_RW(FN, SZ(7), FD(7))
    IF (FD(7) .LT. 0) THEN
       INFO = 7
       RETURN
    END IF

    CALL BOPEN_EW_RW(FN, SZ(8), FD(8))
    IF (FD(8) .LT. 0) THEN
       INFO = 8
       RETURN
    END IF

    CALL BOPEN_SW_RW(FN, SZ(9), FD(9))
    IF (FD(9) .LT. 0) THEN
       INFO = 9
       RETURN
    END IF
  END SUBROUTINE BOPEN_EZS_RW

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! READ routines                                                               !
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  SUBROUTINE BREAD_X(FD, X, L, G, ATOM, INFO)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: FD, L, G, ATOM
    DOUBLE COMPLEX, INTENT(OUT), TARGET :: X(2*L,G)
    INTEGER, INTENT(OUT) :: INFO

    INFO = BREAD(FD, C_LOC(X), C_SIZEOF(X), ATOM * C_SIZEOF(X))
  END SUBROUTINE BREAD_X

  SUBROUTINE BREAD_T(FD, T, L, ATOM, INFO)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: FD, L, ATOM
    DOUBLE COMPLEX, INTENT(OUT), TARGET :: T(2*L,2*L)
    INTEGER, INTENT(OUT) :: INFO

    INFO = BREAD(FD, C_LOC(T), C_SIZEOF(T), ATOM * C_SIZEOF(T))
  END SUBROUTINE BREAD_T

  SUBROUTINE BREAD_U(FD, U, L, ATOM, INFO)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: FD, L, ATOM
    DOUBLE PRECISION, INTENT(OUT), TARGET :: U(L)
    INTEGER, INTENT(OUT) :: INFO

    INFO = BREAD(FD, C_LOC(U), C_SIZEOF(U), ATOM * C_SIZEOF(U))
  END SUBROUTINE BREAD_U

  SUBROUTINE BREAD_XTU(FD, X, T, U, L, G, ATOM, SZ, INFO)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: FD(3), L, G, ATOM
    DOUBLE COMPLEX, INTENT(OUT), TARGET :: X(2*L,G)
    DOUBLE COMPLEX, INTENT(OUT), TARGET :: T(2*L,2*L)
    DOUBLE PRECISION, INTENT(OUT), TARGET :: U(L)
    INTEGER, INTENT(OUT) :: SZ(3), INFO

    INFO = 0

    CALL BREAD_X(FD(1), X, L, G, ATOM, SZ(1))
    IF (SZ(1) .NE. C_SIZEOF(X)) INFO = 1

    CALL BREAD_T(FD(2), T, L, ATOM, SZ(2))
    IF (SZ(2) .NE. C_SIZEOF(T)) INFO = 2

    CALL BREAD_U(FD(3), U, L, ATOM, SZ(3))
    IF (SZ(3) .NE. C_SIZEOF(U)) INFO = 3
  END SUBROUTINE BREAD_XTU

  SUBROUTINE BREAD_Y(FD, Y, L, a, IFCOL, NCOLS, INFO)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: FD, L, a, IFCOL, NCOLS
    DOUBLE COMPLEX, INTENT(OUT), TARGET :: Y(2*L*a,NCOLS)
    INTEGER, INTENT(OUT) :: INFO

    INFO = BREAD(FD, C_LOC(Y), C_SIZEOF(Y), (IFCOL-1) * (2*L*a) * C_SIZEOF(Z_ZERO))
  END SUBROUTINE BREAD_Y

  SUBROUTINE BREAD_W(FD, W, L, a, IFCOL, NCOLS, INFO)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: FD, L, a, IFCOL, NCOLS
    DOUBLE COMPLEX, INTENT(OUT), TARGET :: W(2*L*a,NCOLS)
    INTEGER, INTENT(OUT) :: INFO

    INFO = BREAD(FD, C_LOC(W), C_SIZEOF(W), (IFCOL-1) * (2*L*a) * C_SIZEOF(Z_ZERO))
  END SUBROUTINE BREAD_W

  SUBROUTINE BREAD_YW(FD, Y, W, L, a, IFCOL, NCOLS, SZ, INFO)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: FD(2), L, a, IFCOL, NCOLS
    DOUBLE COMPLEX, INTENT(OUT), TARGET :: Y(2*L*a,NCOLS)
    DOUBLE COMPLEX, INTENT(OUT), TARGET :: W(2*L*a,NCOLS)
    INTEGER, INTENT(OUT) :: SZ(2), INFO

    INFO = 0

    CALL BREAD_Y(FD(1), Y, L, a, IFCOL, NCOLS, SZ(1))
    IF (SZ(1) .NE. C_SIZEOF(Y)) INFO = 1

    CALL BREAD_W(FD(2), W, L, a, IFCOL, NCOLS, SZ(2))
    IF (SZ(2) .NE. C_SIZEOF(W)) INFO = 2
  END SUBROUTINE BREAD_YW

  SUBROUTINE BREAD_J(FD, J, L, a, SZ, INFO)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: FD, L, a
    INTEGER, INTENT(OUT), TARGET :: J(2*L*a)
    INTEGER, INTENT(OUT) :: SZ, INFO

    INFO = 0

    SZ = BREAD(FD, C_LOC(J), C_SIZEOF(J), 0)
    IF (SZ .NE. C_SIZEOF(J)) INFO = 1
  END SUBROUTINE BREAD_J

  SUBROUTINE BREAD_Z(FD, Z, G, SZ, INFO)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: FD, G
    DOUBLE COMPLEX, INTENT(OUT), TARGET :: Z(G,G)
    INTEGER, INTENT(OUT) :: SZ, INFO

    INFO = 0

    SZ = BREAD(FD, C_LOC(Z), C_SIZEOF(Z), 0)
    IF (SZ .NE. C_SIZEOF(Z)) INFO = 1
  END SUBROUTINE BREAD_Z

  SUBROUTINE BREAD_YU(FD, YU, L, a, G, SZ, INFO)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: FD, L, a, G
    DOUBLE COMPLEX, INTENT(OUT), TARGET :: YU(2*L*a,G)
    INTEGER, INTENT(OUT) :: SZ, INFO

    INFO = 0

    SZ = BREAD(FD, C_LOC(YU), C_SIZEOF(YU), 0)
    IF (SZ .NE. C_SIZEOF(YU)) INFO = 1
  END SUBROUTINE BREAD_YU

  SUBROUTINE BREAD_SY(FD, SY, G, SZ, INFO)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: FD, G
    DOUBLE PRECISION, INTENT(OUT), TARGET :: SY(G)
    INTEGER, INTENT(OUT) :: SZ, INFO

    INFO = 0

    SZ = BREAD(FD, C_LOC(SY), C_SIZEOF(SY), 0)
    IF (SZ .NE. C_SIZEOF(SY)) INFO = 1
  END SUBROUTINE BREAD_SY

  SUBROUTINE BREAD_WV(FD, WV, L, a, G, SZ, INFO)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: FD, L, a, G
    DOUBLE COMPLEX, INTENT(OUT), TARGET :: WV(2*L*a,G)
    INTEGER, INTENT(OUT) :: SZ, INFO

    INFO = 0

    SZ = BREAD(FD, C_LOC(WV), C_SIZEOF(WV), 0)
    IF (SZ .NE. C_SIZEOF(WV)) INFO = 1
  END SUBROUTINE BREAD_WV

  SUBROUTINE BREAD_SW(FD, SW, G, SZ, INFO)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: FD, G
    DOUBLE PRECISION, INTENT(OUT), TARGET :: SW(G)
    INTEGER, INTENT(OUT) :: SZ, INFO

    INFO = 0

    SZ = BREAD(FD, C_LOC(SW), C_SIZEOF(SW), 0)
    IF (SZ .NE. C_SIZEOF(SW)) INFO = 1
  END SUBROUTINE BREAD_SW

  SUBROUTINE BREAD_ZZ(FD, ZZ, G, SZ, INFO)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: FD, G
    DOUBLE COMPLEX, INTENT(OUT), TARGET :: ZZ(G,G)
    INTEGER, INTENT(OUT) :: SZ, INFO

    INFO = 0

    SZ = BREAD(FD, C_LOC(ZZ), C_SIZEOF(ZZ), 0)
    IF (SZ .NE. C_SIZEOF(ZZ)) INFO = 1
  END SUBROUTINE BREAD_ZZ

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! WRITE routines                                                              !
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  SUBROUTINE BWRITE_Y(FD, Y, L, G, ATOM, INFO)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: FD, L, G, ATOM
    DOUBLE COMPLEX, INTENT(IN), TARGET :: Y(2*L,G)
    INTEGER, INTENT(OUT) :: INFO

    INFO = BWRITE(FD, C_LOC(Y), C_SIZEOF(Y), ATOM * C_SIZEOF(Y))
  END SUBROUTINE BWRITE_Y

  SUBROUTINE BWRITE_W(FD, W, L, G, ATOM, INFO)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: FD, L, G, ATOM
    DOUBLE COMPLEX, INTENT(IN), TARGET :: W(2*L,G)
    INTEGER, INTENT(OUT) :: INFO

    INFO = BWRITE(FD, C_LOC(W), C_SIZEOF(W), ATOM * C_SIZEOF(W))
  END SUBROUTINE BWRITE_W

  SUBROUTINE BWRITE_J(FD, J, L, ATOM, INFO)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: FD, L, ATOM
    INTEGER, INTENT(IN), TARGET :: J(2*L)
    INTEGER, INTENT(OUT) :: INFO

    INFO = BWRITE(FD, C_LOC(J), C_SIZEOF(J), ATOM * C_SIZEOF(J))
  END SUBROUTINE BWRITE_J

  SUBROUTINE BWRITE_YU(FD, YU, L, a, IFCOL, NCOLS, INFO)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: FD, L, a, IFCOL, NCOLS
    DOUBLE COMPLEX, INTENT(IN), TARGET :: YU(2*L*a,NCOLS)
    INTEGER, INTENT(OUT) :: INFO

    INFO = BWRITE(FD, C_LOC(YU), C_SIZEOF(YU), (IFCOL-1) * (2*L*a) * C_SIZEOF(Z_ZERO))
  END SUBROUTINE BWRITE_YU

  SUBROUTINE BWRITE_WV(FD, WV, L, a, IFCOL, NCOLS, INFO)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: FD, L, a, IFCOL, NCOLS
    DOUBLE COMPLEX, INTENT(IN), TARGET :: WV(2*L*a,NCOLS)
    INTEGER, INTENT(OUT) :: INFO

    INFO = BWRITE(FD, C_LOC(WV), C_SIZEOF(WV), (IFCOL-1) * (2*L*a) * C_SIZEOF(Z_ZERO))
  END SUBROUTINE BWRITE_WV

  SUBROUTINE BWRITE_Z(FD, Z, G, IFCOL, NCOLS, INFO)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: FD, G, IFCOL, NCOLS
    DOUBLE COMPLEX, INTENT(IN), TARGET :: Z(G,NCOLS)
    INTEGER, INTENT(OUT) :: INFO

    INFO = BWRITE(FD, C_LOC(Z), C_SIZEOF(Z), (IFCOL-1) * G * C_SIZEOF(Z_ZERO))
  END SUBROUTINE BWRITE_Z

  SUBROUTINE BWRITE_E(FD, E, IFCOL, NCOLS, INFO)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: FD, IFCOL, NCOLS
    DOUBLE PRECISION, INTENT(IN), TARGET :: E(NCOLS)
    INTEGER, INTENT(OUT) :: INFO

    INFO = BWRITE(FD, C_LOC(E), C_SIZEOF(E), (IFCOL-1) * C_SIZEOF(D_ZERO))
  END SUBROUTINE BWRITE_E

  SUBROUTINE BWRITE_SS(FD, SS, IFCOL, NCOLS, INFO)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: FD, IFCOL, NCOLS
    DOUBLE PRECISION, INTENT(IN), TARGET :: SS(NCOLS)
    INTEGER, INTENT(OUT) :: INFO

    INFO = BWRITE(FD, C_LOC(SS), C_SIZEOF(SS), (IFCOL-1) * C_SIZEOF(D_ZERO))
  END SUBROUTINE BWRITE_SS

  SUBROUTINE BWRITE_EY(FD, EY, IFCOL, NCOLS, INFO)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: FD, IFCOL, NCOLS
    DOUBLE PRECISION, INTENT(IN), TARGET :: EY(NCOLS)
    INTEGER, INTENT(OUT) :: INFO

    INFO = BWRITE(FD, C_LOC(EY), C_SIZEOF(EY), (IFCOL-1) * C_SIZEOF(D_ZERO))
  END SUBROUTINE BWRITE_EY

  SUBROUTINE BWRITE_SY(FD, SY, IFCOL, NCOLS, INFO)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: FD, IFCOL, NCOLS
    DOUBLE PRECISION, INTENT(IN), TARGET :: SY(NCOLS)
    INTEGER, INTENT(OUT) :: INFO

    INFO = BWRITE(FD, C_LOC(SY), C_SIZEOF(SY), (IFCOL-1) * C_SIZEOF(D_ZERO))
  END SUBROUTINE BWRITE_SY

  SUBROUTINE BWRITE_EW(FD, EW, IFCOL, NCOLS, INFO)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: FD, IFCOL, NCOLS
    DOUBLE PRECISION, INTENT(IN), TARGET :: EW(NCOLS)
    INTEGER, INTENT(OUT) :: INFO

    INFO = BWRITE(FD, C_LOC(EW), C_SIZEOF(EW), (IFCOL-1) * C_SIZEOF(D_ZERO))
  END SUBROUTINE BWRITE_EW

  SUBROUTINE BWRITE_SW(FD, SW, IFCOL, NCOLS, INFO)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: FD, IFCOL, NCOLS
    DOUBLE PRECISION, INTENT(IN), TARGET :: SW(NCOLS)
    INTEGER, INTENT(OUT) :: INFO

    INFO = BWRITE(FD, C_LOC(SW), C_SIZEOF(SW), (IFCOL-1) * C_SIZEOF(D_ZERO))
  END SUBROUTINE BWRITE_SW

  SUBROUTINE BWRITE_ZZ(FD, ZZ, G, IFCOL, NCOLS, INFO)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: FD, G, IFCOL, NCOLS
    DOUBLE COMPLEX, INTENT(IN), TARGET :: ZZ(G,NCOLS)
    INTEGER, INTENT(OUT) :: INFO

    INFO = BWRITE(FD, C_LOC(ZZ), C_SIZEOF(ZZ), (IFCOL-1) * G * C_SIZEOF(Z_ZERO))
  END SUBROUTINE BWRITE_ZZ

  SUBROUTINE BWRITE_EZS(FD, E, Z, SS, YU, EY, SY, WV, EW, SW, L, a, G, IFCOL, NCOLS, INFO)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: FD(9), L, a, G, IFCOL, NCOLS
    DOUBLE PRECISION, INTENT(IN), TARGET :: E(NCOLS)
    DOUBLE COMPLEX, INTENT(IN), TARGET :: Z(G,NCOLS)
    DOUBLE PRECISION, INTENT(IN), TARGET :: SS(NCOLS)
    DOUBLE PRECISION, INTENT(IN), TARGET :: EY(NCOLS)
    DOUBLE PRECISION, INTENT(IN), TARGET :: SY(NCOLS)
    DOUBLE PRECISION, INTENT(IN), TARGET :: EW(NCOLS)
    DOUBLE PRECISION, INTENT(IN), TARGET :: SW(NCOLS)
    DOUBLE COMPLEX, INTENT(IN), TARGET :: YU(2*L*a,NCOLS)
    DOUBLE COMPLEX, INTENT(IN), TARGET :: WV(2*L*a,NCOLS)
    INTEGER, INTENT(OUT) :: INFO

    INTEGER(c_size_t) :: SZ(9), S

    SZ(1) = NCOLS * C_SIZEOF(D_ZERO)               !  E
    SZ(2) = G * NCOLS * C_SIZEOF(Z_ZERO)           !  Z

    SZ(3) = NCOLS * C_SIZEOF(D_ZERO)               ! SS
    SZ(4) = (2 * L * a) * NCOLS * C_SIZEOF(Z_ZERO) ! YU
    SZ(5) = NCOLS * C_SIZEOF(D_ZERO)               ! EY
    SZ(6) = NCOLS * C_SIZEOF(D_ZERO)               ! SY
    SZ(7) = (2 * L * a) * NCOLS * C_SIZEOF(Z_ZERO) ! WV
    SZ(8) = NCOLS * C_SIZEOF(D_ZERO)               ! EW
    SZ(9) = NCOLS * C_SIZEOF(D_ZERO)               ! SW

    INFO = 0

    CALL BWRITE_E(FD(1), E, IFCOL, NCOLS, S)
    IF (S .NE. SZ(1)) INFO = 1
    CALL BWRITE_Z(FD(2), Z, G, IFCOL, NCOLS, S)
    IF (S .NE. SZ(2)) INFO = 2

    CALL BWRITE_SS(FD(3), SS, IFCOL, NCOLS, S)
    IF (S .NE. SZ(3)) INFO = 3
    CALL BWRITE_YU(FD(4), YU, L, a, IFCOL, NCOLS, S)
    IF (S .NE. SZ(4)) INFO = 4
    CALL BWRITE_EY(FD(5), EY, IFCOL, NCOLS, S)
    IF (S .NE. SZ(5)) INFO = 5
    CALL BWRITE_SY(FD(6), SY, IFCOL, NCOLS, S)
    IF (S .NE. SZ(6)) INFO = 6
    CALL BWRITE_WV(FD(7), WV, L, a, IFCOL, NCOLS, S)
    IF (S .NE. SZ(7)) INFO = 7
    CALL BWRITE_EW(FD(8), EW, IFCOL, NCOLS, S)
    IF (S .NE. SZ(8)) INFO = 8
    CALL BWRITE_SW(FD(9), SW, IFCOL, NCOLS, S)
    IF (S .NE. SZ(9)) INFO = 9
  END SUBROUTINE BWRITE_EZS

  SUBROUTINE BWRITE_YWJ(FD, Y, W, J, L, G, ATOM, SZ, INFO)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: FD(3), L, G, ATOM
    DOUBLE COMPLEX, INTENT(IN), TARGET :: Y(2*L,G)
    DOUBLE COMPLEX, INTENT(IN), TARGET :: W(2*L,G)
    INTEGER, INTENT(IN), TARGET :: J(2*L)
    INTEGER, INTENT(OUT) :: SZ(3), INFO

    INFO = 0

    CALL BWRITE_Y(FD(1), Y, L, G, ATOM, SZ(1))
    IF (SZ(1) .NE. C_SIZEOF(Y)) INFO = 1

    CALL BWRITE_W(FD(2), W, L, G, ATOM, SZ(2))
    IF (SZ(2) .NE. C_SIZEOF(W)) INFO = 2

    CALL BWRITE_J(FD(3), J, L, ATOM, SZ(3))
    IF (SZ(3) .NE. C_SIZEOF(J)) INFO = 3
  END SUBROUTINE BWRITE_YWJ
END MODULE BINIO
