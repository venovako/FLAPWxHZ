PROGRAM ZHEGVT
  USE BINIO
  USE BLAS_UTILS
  USE TIMER
  USE OMP_LIB
  IMPLICIT NONE

  INTEGER, PARAMETER :: NFLAGS = 4

  CHARACTER(LEN=NFLAGS) :: FLAGS
  CHARACTER(LEN=FNL,KIND=c_char) :: FN
  INTEGER :: M,N,INFO, SZ(3),FD(3), LDA,LDB, ITYPE, LWORK,LRWORK,LIWORK, I,K
  CHARACTER :: JOBZ,UPLO
  LOGICAL :: DC

  DOUBLE COMPLEX :: WORK1(1)
  DOUBLE PRECISION :: RWORK1(2)
  INTEGER :: IWORK1(1)

  ! read F, J
  ! compute A:= F^H J F with timing (put A in MCDRAM)
  ! read G
  ! compute B:= G^H G with timing (put B in MCDRAM)
  ! call ZHEGV(D) with timing

  DOUBLE COMPLEX, ALLOCATABLE, TARGET :: D(:,:)
  INTEGER, ALLOCATABLE, TARGET :: J(:)
  DOUBLE COMPLEX, ALLOCATABLE :: C(:,:)
  !DIR$ ATTRIBUTES ALIGN:ALIGNB :: D,C, J

  DOUBLE COMPLEX, ALLOCATABLE :: A(:,:),B(:,:), WORK(:)
  DOUBLE PRECISION, ALLOCATABLE :: W(:), RWORK(:)
  INTEGER, ALLOCATABLE :: IWORK(:)
#ifdef USE_X200
  !DIR$ ATTRIBUTES MEMKIND:HBW, ALIGN:ALIGNB :: A,B, W, WORK,RWORK,IWORK
#else
  !DIR$ ATTRIBUTES ALIGN:ALIGNB :: A,B, W, WORK,RWORK,IWORK
#endif

  DOUBLE PRECISION, ALLOCATABLE, TARGET :: E(:)
#ifdef USE_X200
  !DIR$ ATTRIBUTES MEMKIND:HBW, ALIGN:ALIGNB :: E
#else
  !DIR$ ATTRIBUTES ALIGN:ALIGNB :: E
#endif

  EXTERNAL :: ZHEGV,ZHEGVD, ZGEMM,ZHERK,ZLACPY, DLASRT

  CALL READCL(FLAGS, M, N, FN, INFO)
  IF (INFO .NE. 0) THEN
     WRITE (ULOG,'(I2,A)',ADVANCE='NO') INFO, ' '
     STOP 'READCL'
  END IF

  SELECT CASE (FLAGS(1:1))
  CASE ('1')
     ITYPE = 1
  CASE ('2')
     ITYPE = 2
  CASE ('3')
     ITYPE = 3
  CASE DEFAULT
     STOP 'ITYPE'
  END SELECT

  SELECT CASE (FLAGS(2:2))
  CASE ('N','n')
     JOBZ = 'N'
  CASE ('V','v')
     JOBZ = 'V'
  CASE DEFAULT
     STOP 'JOBZ'
  END SELECT

  SELECT CASE (FLAGS(3:3))
  CASE ('L','l')
     UPLO = 'L'
  CASE ('U','u')
     UPLO = 'U'
  CASE DEFAULT
     STOP 'UPLO'
  END SELECT

  SELECT CASE (FLAGS(4:4))
  CASE ('D','d')
     DC = .TRUE.
  CASE (' ')
     DC = .FALSE.
  CASE DEFAULT
     STOP 'DC'
  END SELECT

  INFO = BLAS_PREPARE()

  CALL BOPEN_YWJ_RO(FN, M, N, SZ, FD, INFO)
  IF (INFO .NE. 0) THEN
     WRITE (ULOG,'(I2,A)',ADVANCE='NO') INFO, ' '
     STOP 'BOPEN_YWJ_RO'
  END IF

  LDA = N; ALLOCATE(A(LDA,N)); A = Z_ZERO
  LDB = N; ALLOCATE(B(LDB,N)); B = Z_ZERO

  ALLOCATE(D(M,N)); D = Z_ZERO
  ! read F into D
  CALL BREAD_YW(FD(1), D, M, N, SZ(1), INFO)
  IF (INFO .NE. 0) STOP 'BREAD_Y'
  CALL BCLOSE(FD(1))

  ALLOCATE(J(M)); J = 0
  ! read J
  CALL BREAD_JJ(FD(3), J, M, SZ(3), INFO)
  IF (INFO .NE. 0) STOP 'BREAD_JJ'
  CALL BCLOSE(FD(3))

  ALLOCATE(C(M,N)); C = Z_ZERO
  ! copy F to C
  FD(1) = GET_THREAD_NS()
  CALL ZLACPY('A', M, N, D, M, C, M)
  FD(1) = GET_THREAD_NS() - FD(1)
  WRITE (UOUT,'(F12.6,A)',ADVANCE='NO') (FD(1) * DNS2S), ','

  ! obtain JF in D
  FD(3) = GET_THREAD_NS()
  !$OMP PARALLEL DO DEFAULT(NONE) SHARED(M,N,D,J) PRIVATE(I,K) PROC_BIND(SPREAD)
  DO K = 1, N
     DO I = 1, M
        IF (J(I) .EQ. -1) D(I,K) = -D(I,K)
     END DO
  END DO
  !$OMP END PARALLEL DO
  FD(3) = GET_THREAD_NS() - FD(3)
  WRITE (UOUT,'(F12.6,A)',ADVANCE='NO') (FD(3) * DNS2S), ','

  ! multiply C^H D -> A
  SZ(1) = GET_THREAD_NS()
  CALL ZGEMM('C','N', N,N,M, Z_ONE, C,M, D,M, Z_ZERO, A,LDA)
  SZ(1) = GET_THREAD_NS() - SZ(1)
  WRITE (UOUT,'(F12.6,A)',ADVANCE='NO') (SZ(1) * DNS2S), ','

  IF (ALLOCATED(C)) DEALLOCATE(C)
  IF (ALLOCATED(J)) DEALLOCATE(J)

  ! total for preparing A
  SZ(1) = SZ(1) + FD(1) + FD(3)
  WRITE (UOUT,'(F12.6,A)',ADVANCE='NO') (SZ(1) * DNS2S), ','

  ! read G into D
  CALL BREAD_YW(FD(2), D, M, N, SZ(2), INFO)
  IF (INFO .NE. 0) STOP 'BREAD_W'
  CALL BCLOSE(FD(2))

  ! multiply D^H D -> B
  FD(2) = GET_THREAD_NS()
  CALL ZHERK(UPLO,'C', N,M, D_ONE, D,M, D_ZERO, B,LDB)
  FD(2) = GET_THREAD_NS() - FD(2)
  WRITE (UOUT,'(F12.6,A)',ADVANCE='NO') (FD(2) * DNS2S), ','
  ! time for preparing A and B
  WRITE (UOUT,'(F12.6,A)',ADVANCE='NO') ((SZ(1) + FD(2)) * DNS2S), ','

  IF (ALLOCATED(D)) DEALLOCATE(D)
  ALLOCATE(W(N)); W = D_ZERO

  WORK1 = Z_ZERO
  RWORK1 = D_ZERO
  IWORK1 = 0

  LWORK = -1
  LRWORK = -1
  LIWORK = -1

  INFO = 0
  IF (DC) THEN
     CALL ZHEGVD(ITYPE,JOBZ,UPLO, N, A,LDA, B,LDB, W, WORK1,LWORK, RWORK1,LRWORK, IWORK1,LIWORK, INFO)
  ELSE
     CALL ZHEGV(ITYPE,JOBZ,UPLO, N, A,LDA, B,LDB, W, WORK1,LWORK, RWORK1, INFO)
  END IF
  IF (INFO .NE. 0) THEN
     WRITE (ULOG,'(I3,A)',ADVANCE='NO') INFO, ' '
     STOP 'ZHEGVt workspace query'
  END IF
  LWORK = INT(DBLE(WORK1(1)))
  IF (DC) THEN
     LRWORK = INT(RWORK1(1))
     LIWORK = IWORK1(1)
  ELSE
     LRWORK = MAX(1, 3*N-2)
     LIWORK = 0
  END IF

  IF (LWORK .GT. 0) THEN
     ALLOCATE(WORK(LWORK)); WORK = Z_ZERO
  END IF
  IF (LRWORK .GT. 0) THEN
     ALLOCATE(RWORK(LRWORK)); RWORK = D_ZERO
  END IF
  IF (LIWORK .GT. 0) THEN
     ALLOCATE(IWORK(LIWORK)); IWORK = 0
  END IF

  INFO = 0
  SZ(2) = GET_THREAD_NS()
  IF (DC) THEN
     CALL ZHEGVD(ITYPE,JOBZ,UPLO, N, A,LDA, B,LDB, W, WORK,LWORK, RWORK,LRWORK, IWORK,LIWORK, INFO)
  ELSE
     CALL ZHEGV(ITYPE,JOBZ,UPLO, N, A,LDA, B,LDB, W, WORK,LWORK, RWORK, INFO)
  END IF
  SZ(2) = GET_THREAD_NS() - SZ(2)
  WRITE (UOUT,'(F12.6,A)',ADVANCE='NO') (SZ(2) * DNS2S), ','
  ! total time
  SZ(3) = SZ(1) + FD(2) + SZ(2)
  WRITE (UOUT,'(F12.6)') (SZ(3) * DNS2S)
  IF (INFO .NE. 0) THEN
     WRITE (ULOG,'(I7,A)',ADVANCE='NO') INFO, ' '
     STOP 'ZHEGVt'
  END IF

  IF (ALLOCATED(IWORK)) DEALLOCATE(IWORK)
  IF (ALLOCATED(RWORK)) DEALLOCATE(RWORK)
  IF (ALLOCATED(WORK)) DEALLOCATE(WORK)

  ALLOCATE(E(N)); E = D_ZERO
  ! read E
  CALL BOPEN_RO((TRIM(FN)//c_char_'.E'), SZ(1), FD(1))
  IF (FD(1) .LT. 0) STOP 'BOPEN_E_RO'
  CALL BREAD_E(FD(1), E, N, SZ(1), INFO)
  IF (INFO .NE. 0) STOP 'BREAD_E'
  CALL BCLOSE(FD(1))
  ! sort E
  CALL DLASRT('I', N, E, INFO)
  IF (INFO .NE. 0) THEN
     WRITE (ULOG,'(I2,A)',ADVANCE='NO') INFO, ' '
     STOP 'DLASRT'
  END IF
  ! compare E and W
  RWORK1 = D_ZERO
  DO I = 1, N
     WRITE (UOUT,'(I6,A)',ADVANCE='NO') I, ','
     WRITE (UOUT,'(2(ES26.17E4,A))',ADVANCE='NO') W(I),',', E(I),','
     W(I) = W(I) - E(I)
     IF (ABS(W(I)) .GT. RWORK1(1)) RWORK1(1) = ABS(W(I))
     WRITE (UOUT,'(ES26.17E4,A)',ADVANCE='NO') W(I), ','
     W(I) = W(I) / E(I)
     IF (ABS(W(I)) .GT. RWORK1(2)) RWORK1(2) = ABS(W(I))
     WRITE (UOUT,'(ES26.17E4)') W(I)
  END DO
  WRITE (UOUT,'(ES26.17E4,A,ES26.17E4)') RWORK1(1), ',', RWORK1(2)
  IF (ALLOCATED(E)) DEALLOCATE(E)

  IF (ALLOCATED(W)) DEALLOCATE(W)
  IF (ALLOCATED(B)) DEALLOCATE(B)
  IF (ALLOCATED(A)) DEALLOCATE(A)

CONTAINS

  SUBROUTINE READCL(FLAGS, M, N, FN, INFO)
    IMPLICIT NONE
    CHARACTER(LEN=NFLAGS), INTENT(OUT) :: FLAGS
    INTEGER, INTENT(OUT) :: M, N, INFO
    CHARACTER(LEN=*,KIND=c_char), INTENT(OUT) :: FN

    CHARACTER(LEN=FNL) :: ARG
    INTEGER :: TMP

    INFO = 0
    IF (COMMAND_ARGUMENT_COUNT() .NE. 4) STOP 'zhegvt.exe FLAGS M N FN'
    ARG = '                        '
    TMP = 0

    CALL GET_COMMAND_ARGUMENT(1, ARG, TMP, INFO)
    IF (INFO .NE. 0) THEN
       INFO = -1
       RETURN
    END IF
    FLAGS = ARG(1:NFLAGS)
    IF ((TMP .LT. (NFLAGS-1)) .OR. (TMP .GT. NFLAGS) .OR. (LEN_TRIM(FLAGS) .LT. (NFLAGS-1))) THEN
       INFO = 1
       RETURN
    END IF

    CALL GET_COMMAND_ARGUMENT(2, ARG, TMP, INFO)
    IF (INFO .NE. 0) THEN
       INFO = -2
       RETURN
    END IF
    READ (ARG,*) M
    IF (M .LE. 0) THEN
       INFO = 2
       RETURN
    END IF

    CALL GET_COMMAND_ARGUMENT(3, ARG, TMP, INFO)
    IF (INFO .NE. 0) THEN
       INFO = -3
       RETURN
    END IF
    READ (ARG,*) N
    IF ((N .LE. 0) .OR. (M .LT. N)) THEN
       INFO = 3
       RETURN
    END IF

    CALL GET_COMMAND_ARGUMENT(4, ARG, TMP, INFO)
    IF (INFO .NE. 0) THEN
       INFO = -4
       RETURN
    END IF
    FN = TRIM(ARG)
    IF (LEN_TRIM(FN) .LE. 0) THEN
       INFO = 4
       RETURN
    END IF
  END SUBROUTINE READCL

  SUBROUTINE BOPEN_YWJ_RO(FN, M, N, SZ, FD, INFO)
    IMPLICIT NONE
    CHARACTER(LEN=*,KIND=c_char), INTENT(IN) :: FN
    INTEGER, INTENT(IN) :: M, N
    INTEGER, INTENT(OUT) :: SZ(3), FD(3), INFO

    INTEGER :: EXPTSZ(3), DIFFSZ(3)

    SZ = -1
    FD = -1

    INFO = 0
    IF (N .LT. 0) INFO = -3
    IF (M .LT. 0) INFO = -2
    IF (INFO .NE. 0) RETURN

    EXPTSZ(1) = M * N * C_SIZEOF(Z_ZERO)
    EXPTSZ(2) = M * N * C_SIZEOF(Z_ZERO)
    EXPTSZ(3) = M     * C_SIZEOF(0)

    DIFFSZ = 0

    CALL BOPEN_RO((TRIM(FN)//c_char_'.YY'), SZ(1), FD(1))
    IF (FD(1) .LT. 0) THEN
       INFO = 1
       GOTO 1
    END IF
    DIFFSZ(1) = SZ(1) - EXPTSZ(1)
    IF (DIFFSZ(1) .NE. 0) THEN
       INFO = 1
       GOTO 1
    END IF
 
    CALL BOPEN_RO((TRIM(FN)//c_char_'.WW'), SZ(2), FD(2))
    IF (FD(2) .LT. 0) THEN
       INFO = 2
       GOTO 1
    END IF
    DIFFSZ(2) = SZ(2) - EXPTSZ(2)
    IF (DIFFSZ(2) .NE. 0) THEN
       INFO = 2
       GOTO 1
    END IF

    CALL BOPEN_RO((TRIM(FN)//c_char_'.JJ'), SZ(3), FD(3))
    IF (FD(3) .LT. 0) THEN
       INFO = 3
       GOTO 1
    END IF
    DIFFSZ(3) = SZ(3) - EXPTSZ(3)
    IF (DIFFSZ(3) .NE. 0) THEN
       INFO = 3
       GOTO 1
    END IF

    RETURN

1   SZ = DIFFSZ
  END SUBROUTINE BOPEN_YWJ_RO

  SUBROUTINE BREAD_YW(FD, YW, M, N, SZ, INFO)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: FD, M, N
    DOUBLE COMPLEX, INTENT(OUT), TARGET :: YW(M,N)
    INTEGER, INTENT(OUT) :: SZ, INFO

    INTEGER :: I, J

    SZ = M * C_SIZEOF(Z_ZERO)
    INFO = 0

    !$OMP PARALLEL DEFAULT(NONE) PRIVATE(I,J) SHARED(YW,N,FD,SZ) REDUCTION(MAX:INFO)
    INFO = 0
    !$OMP DO
    DO J = 1, N
       I = BREAD(FD, C_LOC(YW(1,J)), SZ, (J-1) * SZ)
       IF (I .NE. SZ) INFO = MAX(INFO,J)
    END DO
    !$OMP END DO
    !$OMP END PARALLEL

    SZ = SZ * N
  END SUBROUTINE BREAD_YW

  SUBROUTINE BREAD_JJ(FD, JJ, M, SZ, INFO)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: FD, M
    INTEGER, INTENT(OUT), TARGET :: JJ(M)
    INTEGER, INTENT(OUT) :: SZ, INFO

    INTEGER :: I, J, TN, NT

    SZ = C_SIZEOF(0)
    INFO = 0

    !$OMP PARALLEL DEFAULT(NONE) PRIVATE(I,J,TN,NT) SHARED(JJ,M,FD,SZ) REDUCTION(MAX:INFO)
    INFO = 0
    TN = OMP_GET_THREAD_NUM()
    NT = OMP_GET_NUM_THREADS()
    IF (TN .EQ. 0) THEN
       I = (M / NT) + MOD(M,NT)
       J = 0
    ELSE ! TN .GT. 0
       I = M / NT
       J = TN * I + MOD(M,NT)
    END IF
    IF (I .GT. 0) THEN
       I = I * SZ
       J = BREAD(FD, C_LOC(JJ(J+1)), I, J * SZ)
       IF (J .NE. I) INFO = MAX(INFO,(TN+1))
    END IF
    !$OMP END PARALLEL

    SZ = SZ * M
  END SUBROUTINE BREAD_JJ

  SUBROUTINE BREAD_E(FD, E, N, SZ, INFO)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: FD, N
    DOUBLE PRECISION, INTENT(OUT), TARGET :: E(N)
    INTEGER, INTENT(OUT) :: SZ, INFO

    INTEGER :: I, J, TN, NT

    SZ = C_SIZEOF(D_ZERO)
    INFO = 0

    !$OMP PARALLEL DEFAULT(NONE) PRIVATE(I,J,TN,NT) SHARED(E,N,FD,SZ) REDUCTION(MAX:INFO)
    INFO = 0
    TN = OMP_GET_THREAD_NUM()
    NT = OMP_GET_NUM_THREADS()
    IF (TN .EQ. 0) THEN
       I = (N / NT) + MOD(N,NT)
       J = 0
    ELSE ! TN .GT. 0
       I = N / NT
       J = TN * I + MOD(N,NT)
    END IF
    IF (I .GT. 0) THEN
       I = I * SZ
       J = BREAD(FD, C_LOC(E(J+1)), I, J * SZ)
       IF (J .NE. I) INFO = MAX(INFO,(TN+1))
    END IF
    !$OMP END PARALLEL

    SZ = SZ * N
  END SUBROUTINE BREAD_E

END PROGRAM ZHEGVT
