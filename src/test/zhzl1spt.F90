PROGRAM ZHZL1SPT
  USE BINIO
  USE BLAS_UTILS
  USE HIF_HZ
  USE JACSTR
  USE TIMER
  IMPLICIT NONE

  INTEGER, PARAMETER :: FNL = 20

  CHARACTER(LEN=FNL,KIND=c_char) :: FN
  INTEGER :: K,NPLUS,NSWP,CPR, LDB, JSTRAT,NPAIRS,NSTEPS, I,FD(2),SZ(2), NROT(2),INFO

  INTEGER, TARGET :: JS(8)
  !DIR$ ATTRIBUTES ALIGN:ALIGNB :: JS

  INTEGER, ALLOCATABLE, TARGET :: JSARR(:,:), JSPAIR(:,:,:)
#ifdef USE_X200
  !DIR$ ATTRIBUTES MEMKIND:HBW, ALIGN:ALIGNB :: JSARR,JSPAIR
#else
  !DIR$ ATTRIBUTES ALIGN:ALIGNB :: JSARR,JSPAIR
#endif
  DOUBLE COMPLEX, ALLOCATABLE :: BH(:,:), BS(:,:), BZ(:,:)
#ifdef USE_X200
  !DIR$ ATTRIBUTES MEMKIND:HBW, ALIGN:ALIGNB :: BH,BS,BZ
#else
  !DIR$ ATTRIBUTES ALIGN:ALIGNB :: BH,BS,BZ
#endif

  CALL READCL(FN, K, JSTRAT, NSWP, CPR, INFO)
  IF (INFO .NE. 0) STOP 'Error in READCL'

  NPAIRS = K / 2
  INFO = MOD(K, 2)
  IF (INFO .NE. 0) STOP 'K mod 2 =/= 0'
  LDB = K
  INFO = MOD(LDB, ZALIGN)
  IF (INFO .NE. 0) STOP 'LDB mod ZALIGN =/= 0'
  ! For this test, J = I
  NPLUS = K

  SELECT CASE (JSTRAT)
  CASE (JSMENC,JSMMNC)
     CONTINUE
  CASE DEFAULT
     STOP 'JSTRAT not JSMENC(2) nor JSMMNC(4)'
  END SELECT
  CALL JSTRAT_INIT(JS, JSTRAT, K, NSTEPS)
  IF (NSTEPS .LE. 0) STOP 'Error in JSTRAT_INIT'
  ALLOCATE(JSPAIR(2,NPAIRS,NSTEPS),STAT=INFO)
  IF (INFO .GT. 0) STOP 'Error allocating JSPAIR'
  ALLOCATE(JSARR(2,NPAIRS),STAT=INFO)
  IF (INFO .GT. 0) STOP 'Error allocating JSARR'  
  DO I = 1, NSTEPS
     CALL JSTRAT_NEXT_NC(JS, JSARR, INFO)
     CALL JSTRAT_UNPACK_NC(JS, JSARR, JSPAIR(1,1,I), INFO)
     IF (INFO .NE. NPAIRS) STOP 'Error in JSTRAT_NEXT/UNPACK_NC'
  END DO
  IF (ALLOCATED(JSARR)) DEALLOCATE(JSARR)

  CALL BOPEN_YW_RO(FN, LDB, K, SZ, FD, INFO)
  IF (INFO .NE. 0) STOP 'Error in BOPEN_YW_RO'

  ALLOCATE(BH(LDB,K),STAT=INFO)
  IF (INFO .GT. 0) STOP 'Error allocating BH'
  ALLOCATE(BS(LDB,K),STAT=INFO)
  IF (INFO .GT. 0) STOP 'Error allocating BS'

  CALL BREAD_YW(FD, BH, BS, LDB, K, SZ, INFO)
  IF (INFO .NE. 0) STOP 'Error in BREAD_YW'
  CALL BCLOSEN(FD, 3)

  ALLOCATE(BZ(LDB,K),STAT=INFO)
  IF (INFO .GT. 0) STOP 'Error allocating BZ'

  INFO = BLAS_PREPARE()
  I = GET_THREAD_NS()
  IF (CPR .EQ. 0) THEN
     CALL ZHZL1S(K, BH,NPLUS, BS,BZ, LDB, JS,JSPAIR, NSWP, NROT,INFO)
  ELSE
     CALL ZHZL1P(K, BH,NPLUS, BS,BZ, LDB, JS,JSPAIR, NSWP,CPR, NROT,INFO)
  END IF
  I = GET_THREAD_NS() - I
  WRITE (UOUT,'(I6,A,I1,A,2(I3,A),2(I20,A),F15.6)') K,',',JSTRAT,',',CPR,',',INFO,',',NROT(1),',',NROT(2),',',(I*DNS2S)

  IF (ALLOCATED(BZ)) DEALLOCATE(BZ)
  IF (ALLOCATED(BS)) DEALLOCATE(BS)
  IF (ALLOCATED(BH)) DEALLOCATE(BH)
  IF (ALLOCATED(JSPAIR)) DEALLOCATE(JSPAIR)

CONTAINS

  SUBROUTINE READCL(FN, K, JSTRAT, NSWP, CPR, INFO)
    IMPLICIT NONE
    CHARACTER(LEN=*,KIND=c_char), INTENT(OUT) :: FN
    INTEGER, INTENT(OUT) :: K, JSTRAT, NSWP, CPR, INFO

    CHARACTER(LEN=FNL) :: ARG
    INTEGER :: TMP

    INFO = 0
    IF (COMMAND_ARGUMENT_COUNT() .NE. 5) STOP 'zhzl1spt.exe FN K JSTRAT NSWP CPR'

    CALL GET_COMMAND_ARGUMENT(1, ARG, TMP, INFO)
    IF (INFO .NE. 0) THEN
       INFO = -1
       RETURN
    END IF
    FN = TRIM(ARG)
    IF (LEN_TRIM(FN) .LE. 0) THEN
       INFO = 1
       RETURN
    END IF

    CALL GET_COMMAND_ARGUMENT(2, ARG, TMP, INFO)
    IF (INFO .NE. 0) THEN
       INFO = -2
       RETURN
    END IF
    READ (ARG,*) K
    IF (K .LE. 0) THEN
       INFO = 2
       RETURN
    END IF

    CALL GET_COMMAND_ARGUMENT(3, ARG, TMP, INFO)
    IF (INFO .NE. 0) THEN
       INFO = -3
       RETURN
    END IF
    READ (ARG,*) JSTRAT
    IF ((JSTRAT .LT. 0) .OR. (JSTRAT .GT. JSMMWC)) THEN
       INFO = 3
       RETURN
    END IF

    CALL GET_COMMAND_ARGUMENT(4, ARG, TMP, INFO)
    IF (INFO .NE. 0) THEN
       INFO = -4
       RETURN
    END IF
    READ (ARG,*) NSWP
    IF (NSWP .LT. 0) THEN
       INFO = 4
       RETURN
    END IF

    CALL GET_COMMAND_ARGUMENT(5, ARG, TMP, INFO)
    IF (INFO .NE. 0) THEN
       INFO = -5
       RETURN
    END IF
    READ (ARG,*) CPR
    IF (CPR .LT. 0) THEN
       INFO = 5
       RETURN
    END IF
  END SUBROUTINE READCL

  SUBROUTINE BOPEN_YW_RO(FN, M, N, SZ, FD, INFO)
    IMPLICIT NONE
    CHARACTER(LEN=*,KIND=c_char), INTENT(IN) :: FN
    INTEGER, INTENT(IN) :: M, N
    INTEGER, INTENT(OUT) :: SZ(2), FD(2), INFO

    INTEGER :: EXPTSZ(2), DIFFSZ(2)

    SZ = -1
    FD = -1

    INFO = 0
    IF (K .LT. 0) INFO = -2
    IF (INFO .NE. 0) RETURN

    EXPTSZ(1) = M * N * C_SIZEOF(Z_ZERO)
    EXPTSZ(2) = M * N * C_SIZEOF(Z_ZERO)

    DIFFSZ = 0

    CALL BOPEN_RO((TRIM(FN)//c_char_'.Y'), SZ(1), FD(1))
    IF (FD(1) .LT. 0) THEN
       INFO = 1
       GOTO 1
    END IF
    DIFFSZ(1) = SZ(1) - EXPTSZ(1)
    IF (DIFFSZ(1) .NE. 0) THEN
       INFO = 1
       GOTO 1
    END IF
 
    CALL BOPEN_RO((TRIM(FN)//c_char_'.W'), SZ(2), FD(2))
    IF (FD(2) .LT. 0) THEN
       INFO = 2
       GOTO 1
    END IF
    DIFFSZ(2) = SZ(2) - EXPTSZ(2)
    IF (DIFFSZ(2) .NE. 0) THEN
       INFO = 2
       GOTO 1
    END IF

    RETURN

1   SZ = DIFFSZ
  END SUBROUTINE BOPEN_YW_RO

  SUBROUTINE BREAD_YW(FD, Y, W, M, N, SZ, INFO)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: FD(2), M, N
    DOUBLE COMPLEX, INTENT(OUT), TARGET :: Y(M,N), W(M,N)
    INTEGER, INTENT(OUT) :: SZ(2), INFO

    INFO = 0

    SZ(1) = BREAD(FD(1), C_LOC(Y), C_SIZEOF(Y), 0)
    IF (SZ(1) .NE. C_SIZEOF(Y)) THEN
       INFO = 1
       RETURN
    END IF

    SZ(2) = BREAD(FD(2), C_LOC(Y), C_SIZEOF(Y), 0)
    IF (SZ(2) .NE. C_SIZEOF(W)) THEN
       INFO = 2
       RETURN
    END IF
  END SUBROUTINE BREAD_YW

END PROGRAM ZHZL1SPT
