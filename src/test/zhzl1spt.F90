PROGRAM ZHZL1SPT
  USE BINIO
  USE BLAS_UTILS
  USE HIF_HZ
  USE JACSTR
  USE TIMER
  IMPLICIT NONE

  INTEGER, PARAMETER :: FNL = 20

  CHARACTER(LEN=FNL,KIND=c_char) :: FN
  INTEGER :: M,N,NSWP,CPR, K,NPLUS,LDB, JSTRAT,NPAIRS,NSTEPS, I,FD(3),SZ(3), JNBLKS, NROT(2),INFO

  INTEGER, TARGET :: JS(JSMLEX)
  !DIR$ ATTRIBUTES ALIGN:ALIGNB :: JS

  INTEGER, ALLOCATABLE, TARGET :: JSPAIR(:,:,:), IPIV(:),JVEC(:),IPL(:),INVP(:)
#ifdef USE_X200
  !DIR$ ATTRIBUTES MEMKIND:HBW, ALIGN:ALIGNB :: JSPAIR
#else
  !DIR$ ATTRIBUTES ALIGN:ALIGNB :: JSPAIR
#endif
  DOUBLE COMPLEX, ALLOCATABLE, TARGET :: Y(:,:),W(:,:),YU(:,:)
  !DIR$ ATTRIBUTES ALIGN:ALIGNB :: Y,W,YU
  INTEGER, ALLOCATABLE, TARGET :: J(:), JNSTIX(:),JNLENS(:)
  !DIR$ ATTRIBUTES ALIGN:ALIGNB :: J, JNSTIX,JNLENS
  DOUBLE COMPLEX, ALLOCATABLE :: H(:,:),S(:,:),Z(:,:)
#ifdef USE_X200
  !DIR$ ATTRIBUTES MEMKIND:HBW, ALIGN:ALIGNB :: H,S,Z
#else
  !DIR$ ATTRIBUTES ALIGN:ALIGNB :: H,S,Z
#endif

  CALL READCL(FN, M, N, JSTRAT, NSWP, CPR, INFO)
  IF (INFO .NE. 0) STOP 'Error in READCL'
  IF (N .GT. M) STOP 'N > M'
  K = N
  INFO = MOD(K, 2)
  IF (INFO .NE. 0) STOP 'K mod 2 =/= 0'
  NPAIRS = K / 2
  LDB = K
  INFO = MOD(LDB, ZALIGN)
  IF (INFO .NE. 0) STOP 'LDB mod ZALIGN =/= 0'

  SELECT CASE (JSTRAT)
  CASE (JSMENC,JSMMNC)
     CONTINUE
  CASE DEFAULT
     STOP 'JSTRAT not JSMENC(2) nor JSMMNC(4)'
  END SELECT
  CALL JSTRAT_INIT(JS, JSTRAT, K, NSTEPS)
  IF (NSTEPS .LE. 0) STOP 'Error in JSTRAT_INIT'
  ALLOCATE(JSPAIR(2,NPAIRS,NSTEPS),STAT=INFO)
  IF (INFO .GT. 0) STOP 'Error allocating JSPAIR'
  CALL JSTRAT_SWEEP_NC(JS, NSTEPS, NPAIRS, JSPAIR, INFO)
  IF (INFO .NE. 0) STOP 'Error in JSTRAT_NEXT/UNPACK_NC'

  CALL BOPEN_YWJ_RO(FN, M, N, SZ, FD, INFO)
  IF (INFO .NE. 0) STOP 'Error in BOPEN_YWJ_RO'
  ALLOCATE(Y(M,N),STAT=INFO)
  IF (INFO .GT. 0) STOP 'Error allocating Y'
  ALLOCATE(W(M,N),STAT=INFO)
  IF (INFO .GT. 0) STOP 'Error allocating W'
  ALLOCATE(J(M),STAT=INFO)
  IF (INFO .GT. 0) STOP 'Error allocating J'
  CALL BREAD_YWJ(FD, Y, W, J, M, N, SZ, INFO)
  IF (INFO .NE. 0) STOP 'Error in BREAD_YWJ'
  CALL BCLOSEN(FD, 3)

  ALLOCATE(H(LDB,K),STAT=INFO)
  IF (INFO .GT. 0) STOP 'Error allocating H'
  ALLOCATE(S(LDB,K),STAT=INFO)
  IF (INFO .GT. 0) STOP 'Error allocating S'
  ALLOCATE(Z(LDB,K),STAT=INFO)
  IF (INFO .GT. 0) STOP 'Error allocating Z'

  ALLOCATE(JNSTIX(M),STAT=INFO)
  IF (INFO .GT. 0) STOP 'Error allocating JNSTIX'
  ALLOCATE(JNLENS(M),STAT=INFO)
  IF (INFO .GT. 0) STOP 'Error allocating JNLENS'
  CALL JANAL(M, J, NPLUS, JNBLKS, JNSTIX,JNLENS)
  ALLOCATE(YU(M,N),STAT=INFO)
  IF (INFO .GT. 0) STOP 'Error allocating YU'
  ALLOCATE(IPIV(K),STAT=INFO)
  IF (INFO .GT. 0) STOP 'Error allocating IPIV'
  ALLOCATE(JVEC(K),STAT=INFO)
  IF (INFO .GT. 0) STOP 'Error allocating JVEC'
  ALLOCATE(IPL(K),STAT=INFO)
  IF (INFO .GT. 0) STOP 'Error allocating IPL'
  ALLOCATE(INVP(K),STAT=INFO)
  IF (INFO .GT. 0) STOP 'Error allocating INVP'

  INFO = BLAS_PREPARE()
  CALL ZPREP_BLKS(M,N,K, Y,YU,M, W,M, JNSTIX,JNLENS,JNBLKS,NPLUS, IPIV,JVEC,IPL,INVP, I, H,S,Z,LDB, NROT)
  IF ((NROT(1) .NE. 0) .OR. (NROT(2) .NE. 0)) STOP 'Error in ZPREP_BLKS'
  NPLUS = I

  IF (ALLOCATED(INVP)) DEALLOCATE(INVP)
  IF (ALLOCATED(IPL)) DEALLOCATE(IPL)
  IF (ALLOCATED(JVEC)) DEALLOCATE(JVEC)
  IF (ALLOCATED(IPIV)) DEALLOCATE(IPIV)
  IF (ALLOCATED(YU)) DEALLOCATE(YU)
  IF (ALLOCATED(JNLENS)) DEALLOCATE(JNLENS)
  IF (ALLOCATED(JNSTIX)) DEALLOCATE(JNSTIX)

  I = GET_THREAD_NS()
  IF (CPR .EQ. 0) THEN
     CALL ZHZL1S(K, H,NPLUS, S,Z, LDB, JS,JSPAIR, NSWP, NROT,INFO)
  ELSE
     CALL ZHZL1P(K, H,NPLUS, S,Z, LDB, JS,JSPAIR, NSWP,CPR, NROT,INFO)
  END IF
  I = GET_THREAD_NS() - I
  WRITE (UOUT,'(I6,A,I1,A,2(I3,A),2(I20,A),F15.6)') K,',',JSTRAT,',',CPR,',',INFO,',',NROT(1),',',NROT(2),',',(I*DNS2S)

  IF (ALLOCATED(Z)) DEALLOCATE(Z)
  IF (ALLOCATED(S)) DEALLOCATE(S)
  IF (ALLOCATED(H)) DEALLOCATE(H)
  IF (ALLOCATED(J)) DEALLOCATE(J)
  IF (ALLOCATED(W)) DEALLOCATE(W)
  IF (ALLOCATED(Y)) DEALLOCATE(Y)
  IF (ALLOCATED(JSPAIR)) DEALLOCATE(JSPAIR)

CONTAINS

  SUBROUTINE READCL(FN, M, N, JSTRAT, NSWP, CPR, INFO)
    IMPLICIT NONE
    CHARACTER(LEN=*,KIND=c_char), INTENT(OUT) :: FN
    INTEGER, INTENT(OUT) :: M, N, JSTRAT, NSWP, CPR, INFO

    CHARACTER(LEN=FNL) :: ARG
    INTEGER :: TMP

    INFO = 0
    IF (COMMAND_ARGUMENT_COUNT() .NE. 6) STOP 'zhzl1spt.exe FN M N JSTRAT NSWP CPR'

    CALL GET_COMMAND_ARGUMENT(1, ARG, TMP, INFO)
    IF (INFO .NE. 0) THEN
       INFO = -1
       RETURN
    END IF
    FN = TRIM(ARG)
    IF (LEN_TRIM(FN) .LE. 0) THEN
       INFO = 1
       RETURN
    END IF

    CALL GET_COMMAND_ARGUMENT(2, ARG, TMP, INFO)
    IF (INFO .NE. 0) THEN
       INFO = -2
       RETURN
    END IF
    READ (ARG,*) M
    IF (M .LE. 0) THEN
       INFO = 2
       RETURN
    END IF

    CALL GET_COMMAND_ARGUMENT(3, ARG, TMP, INFO)
    IF (INFO .NE. 0) THEN
       INFO = -3
       RETURN
    END IF
    READ (ARG,*) N
    IF (N .LE. 0) THEN
       INFO = 3
       RETURN
    END IF

    CALL GET_COMMAND_ARGUMENT(4, ARG, TMP, INFO)
    IF (INFO .NE. 0) THEN
       INFO = -4
       RETURN
    END IF
    READ (ARG,*) JSTRAT
    IF ((JSTRAT .LT. 0) .OR. (JSTRAT .GT. JSMMWC)) THEN
       INFO = 4
       RETURN
    END IF

    CALL GET_COMMAND_ARGUMENT(5, ARG, TMP, INFO)
    IF (INFO .NE. 0) THEN
       INFO = -5
       RETURN
    END IF
    READ (ARG,*) NSWP
    IF (NSWP .LT. 0) THEN
       INFO = 5
       RETURN
    END IF

    CALL GET_COMMAND_ARGUMENT(6, ARG, TMP, INFO)
    IF (INFO .NE. 0) THEN
       INFO = -6
       RETURN
    END IF
    READ (ARG,*) CPR
    IF (CPR .LT. 0) THEN
       INFO = 6
       RETURN
    END IF
  END SUBROUTINE READCL

  SUBROUTINE BOPEN_YWJ_RO(FN, M, N, SZ, FD, INFO)
    IMPLICIT NONE
    CHARACTER(LEN=*,KIND=c_char), INTENT(IN) :: FN
    INTEGER, INTENT(IN) :: M, N
    INTEGER, INTENT(OUT) :: SZ(3), FD(3), INFO

    INTEGER :: EXPTSZ(3), DIFFSZ(3)

    SZ = -1
    FD = -1

    INFO = 0
    IF (N .LT. 0) INFO = -3
    IF (M .LT. 0) INFO = -2
    IF (INFO .NE. 0) RETURN

    EXPTSZ(1) = M * N * C_SIZEOF(Z_ZERO)
    EXPTSZ(2) = M * N * C_SIZEOF(Z_ZERO)
    EXPTSZ(3) = M     * C_SIZEOF(0)

    DIFFSZ = 0

    CALL BOPEN_RO((TRIM(FN)//c_char_'.Y'), SZ(1), FD(1))
    IF (FD(1) .LT. 0) THEN
       INFO = 1
       GOTO 1
    END IF
    DIFFSZ(1) = SZ(1) - EXPTSZ(1)
    IF (DIFFSZ(1) .NE. 0) THEN
       INFO = 1
       GOTO 1
    END IF
 
    CALL BOPEN_RO((TRIM(FN)//c_char_'.W'), SZ(2), FD(2))
    IF (FD(2) .LT. 0) THEN
       INFO = 2
       GOTO 1
    END IF
    DIFFSZ(2) = SZ(2) - EXPTSZ(2)
    IF (DIFFSZ(2) .NE. 0) THEN
       INFO = 2
       GOTO 1
    END IF

    CALL BOPEN_RO((TRIM(FN)//c_char_'.J'), SZ(3), FD(3))
    IF (FD(3) .LT. 0) THEN
       INFO = 3
       GOTO 1
    END IF
    DIFFSZ(3) = SZ(3) - EXPTSZ(3)
    IF (DIFFSZ(3) .NE. 0) THEN
       INFO = 3
       GOTO 1
    END IF

    RETURN

1   SZ = DIFFSZ
  END SUBROUTINE BOPEN_YWJ_RO

  SUBROUTINE BREAD_YWJ(FD, Y, W, J, M, N, SZ, INFO)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: FD(3), M, N
    DOUBLE COMPLEX, INTENT(OUT), TARGET :: Y(M,N), W(M,N)
    INTEGER, INTENT(OUT), TARGET :: J(M)
    INTEGER, INTENT(OUT) :: SZ(3), INFO

    INFO = 0

    SZ(1) = BREAD(FD(1), C_LOC(Y), C_SIZEOF(Y), 0)
    IF (SZ(1) .NE. C_SIZEOF(Y)) THEN
       INFO = 1
       RETURN
    END IF

    SZ(2) = BREAD(FD(2), C_LOC(Y), C_SIZEOF(Y), 0)
    IF (SZ(2) .NE. C_SIZEOF(W)) THEN
       INFO = 2
       RETURN
    END IF

    SZ(3) = BREAD(FD(3), C_LOC(J), C_SIZEOF(J), 0)
    IF (SZ(3) .NE. C_SIZEOF(J)) THEN
       INFO = 3
       RETURN
    END IF
  END SUBROUTINE BREAD_YWJ

END PROGRAM ZHZL1SPT
