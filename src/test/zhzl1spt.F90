PROGRAM ZHZL1SPT
  USE BINIO
  USE HIF_HZ
  USE TIMER
  USE OMP_LIB
  IMPLICIT NONE

  CHARACTER(LEN=FNL,KIND=c_char) :: FN
  INTEGER :: M,MM,N,NN,NSWP,TPC, LDH,LDS,LDZ, JSTRAT,NPAIRS,NSTEPS, I,FD(9),SZ(9), NROT(2),INFO

  INTEGER, TARGET :: JS(JSMLEX)
  !DIR$ ATTRIBUTES ALIGN:ALIGNB :: JS

  INTEGER, ALLOCATABLE, TARGET :: JSPAIR(:,:,:), J(:)
  !DIR$ ATTRIBUTES ALIGN:ALIGNB :: JSPAIR, J
  DOUBLE COMPLEX, ALLOCATABLE, TARGET :: H(:,:),S(:,:)
  !DIR$ ATTRIBUTES ALIGN:ALIGNB :: H,S
  DOUBLE COMPLEX, ALLOCATABLE :: Z(:,:)
  !DIR$ ATTRIBUTES ALIGN:ALIGNB :: Z
  DOUBLE PRECISION, ALLOCATABLE, TARGET :: E(:),EY(:),EW(:), SY(:),SW(:),SS(:)
  !DIR$ ATTRIBUTES ALIGN:ALIGNB :: E,EY,EW, SY,SW,SS

  CALL READCL(FN, M, N, JSTRAT, NSWP, TPC, INFO)
  IF (INFO .NE. 0) STOP 'Error in READCL'
  NN = N + MOD(N,2)
  NPAIRS = NN / 2
  IF (NN .GT. M) THEN
     MM = NN
  ELSE
     MM = M
  END IF
  LDH = LDALIGN(MM, ZALIGN)
  LDS = LDALIGN(MM, ZALIGN)
  LDZ = LDALIGN(NN, ZALIGN)

  SELECT CASE (JSTRAT)
  CASE (JSMENC,JSMMNC)
     CONTINUE
  CASE DEFAULT
     STOP 'JSTRAT not JSMENC(2) nor JSMMNC(4)'
  END SELECT
  CALL JSTRAT_INIT(JS, JSTRAT, NN, NSTEPS)
  IF (NSTEPS .LE. 0) STOP 'Error in JSTRAT_INIT'
  ALLOCATE(JSPAIR(2,NPAIRS,NSTEPS),STAT=INFO)
  !DIR$ VECTOR ALWAYS ALIGNED
  JSPAIR = 0
  IF (INFO .GT. 0) STOP 'Error allocating JSPAIR'
  CALL JSTRAT_SWEEP_NC(JS, NSTEPS, NPAIRS, JSPAIR, INFO)
  IF (INFO .NE. 0) STOP 'Error in JSTRAT_NEXT/UNPACK_NC'

  CALL BOPEN_YWJ_RO(FN, M, N, SZ, FD, INFO)
  IF (INFO .NE. 0) STOP 'Error in BOPEN_YWJ_RO'
  ALLOCATE(H(LDH,NN),STAT=INFO)
  !DIR$ VECTOR ALWAYS ALIGNED
  H = Z_ZERO
  IF (INFO .GT. 0) STOP 'Error allocating H'
  ALLOCATE(S(LDS,NN),STAT=INFO)
  !DIR$ VECTOR ALWAYS ALIGNED
  S = Z_ZERO
  IF (INFO .GT. 0) STOP 'Error allocating S'
  ALLOCATE(J(MM),STAT=INFO)
  !DIR$ VECTOR ALWAYS ALIGNED
  J = 0
  IF (INFO .GT. 0) STOP 'Error allocating J'
  CALL BREAD_YWJ(FD, H, LDH, S, LDS, J, M, N, SZ, INFO)
  IF (INFO .NE. 0) STOP 'Error in BREAD_YWJ'
  CALL BCLOSEN(FD, 3)
  ALLOCATE(Z(LDZ,NN),STAT=INFO)
  !DIR$ VECTOR ALWAYS ALIGNED
  Z = Z_ZERO
  IF (INFO .GT. 0) STOP 'Error allocating Z'
  ALLOCATE(E(NN),STAT=INFO)
  !DIR$ VECTOR ALWAYS ALIGNED
  E = D_ZERO
  IF (INFO .GT. 0) STOP 'Error allocating E'

  ALLOCATE(EY(NN),STAT=INFO)
  !DIR$ VECTOR ALWAYS ALIGNED
  EY = D_ZERO
  IF (INFO .GT. 0) STOP 'Error allocating EY'
  ALLOCATE(EW(NN),STAT=INFO)
  !DIR$ VECTOR ALWAYS ALIGNED
  EW = D_ZERO
  IF (INFO .GT. 0) STOP 'Error allocating EW'
  ALLOCATE(SY(NN),STAT=INFO)
  !DIR$ VECTOR ALWAYS ALIGNED
  SY = D_ZERO
  IF (INFO .GT. 0) STOP 'Error allocating SY'
  ALLOCATE(SW(NN),STAT=INFO)
  !DIR$ VECTOR ALWAYS ALIGNED
  SW = D_ZERO
  IF (INFO .GT. 0) STOP 'Error allocating SW'
  ALLOCATE(SS(NN),STAT=INFO)
  !DIR$ VECTOR ALWAYS ALIGNED
  SS = D_ZERO
  IF (INFO .GT. 0) STOP 'Error allocating SS'

  DO I = N+1, NN
     H(I,I) = Z_ONE
     S(I,I) = Z_ONE
  END DO
  DO I = M+1, MM
     J(I) = 1
  END DO

  INFO = BLAS_PREPARE()
  I = GET_THREAD_NS()
  IF (TPC .EQ. 0) THEN
     CALL ZHZL1S(MM,NN, H,LDH, J, S,LDS, Z,LDZ, JS,JSPAIR, NSWP, E,EY,EW, SY,SW,SS, NROT,INFO)
  ELSE
     CALL ZHZL1P(MM,NN, H,LDH, J, S,LDS, Z,LDZ, JS,JSPAIR, NSWP,TPC, E,EY,EW, SY,SW,SS, NROT,INFO)
  END IF
  I = GET_THREAD_NS() - I
  WRITE (UOUT,'(2(I6,A),I1,A,I3,A,2(I20,A),F15.6)') &
       M,',',N,',',JSTRAT,',',INFO,',',NROT(1),',',NROT(2),',',(I*DNS2S)

  CALL BOPEN_EZS_RW(FN, M, N, SZ, FD, INFO)
  IF (INFO .NE. 0) STOP 'Error in BOPEN_EZS_RW'
  CALL BWRITE_EZS(FD, E, Z, LDZ, SS, H, LDH, EY, SY, S, LDS, EW, SW, M, N, SZ, INFO)
  IF (INFO .NE. 0) STOP 'Error in BWRITE_EZS'
  CALL BCLOSEN(FD, 9)

  IF (ALLOCATED(SS)) DEALLOCATE(SS)
  IF (ALLOCATED(SW)) DEALLOCATE(SW)
  IF (ALLOCATED(SY)) DEALLOCATE(SY)
  IF (ALLOCATED(EW)) DEALLOCATE(EW)
  IF (ALLOCATED(EY)) DEALLOCATE(EY)

  IF (ALLOCATED(E)) DEALLOCATE(E)
  IF (ALLOCATED(Z)) DEALLOCATE(Z)
  IF (ALLOCATED(J)) DEALLOCATE(J)
  IF (ALLOCATED(S)) DEALLOCATE(S)
  IF (ALLOCATED(H)) DEALLOCATE(H)

CONTAINS

  SUBROUTINE READCL(FN, M, N, JSTRAT, NSWP, TPC, INFO)
    IMPLICIT NONE
    CHARACTER(LEN=*,KIND=c_char), INTENT(OUT) :: FN
    INTEGER, INTENT(OUT) :: M, N, JSTRAT, NSWP, TPC, INFO

    CHARACTER(LEN=FNL) :: ARG
    INTEGER :: TMP

    INFO = 0
    IF (COMMAND_ARGUMENT_COUNT() .NE. 6) STOP 'zhzl1spt.exe FN M N JSTRAT NSWP TPC'

    CALL GET_COMMAND_ARGUMENT(1, ARG, TMP, INFO)
    IF (INFO .NE. 0) THEN
       INFO = -1
       RETURN
    END IF
    FN = TRIM(ARG)
    IF (LEN_TRIM(FN) .LE. 0) THEN
       INFO = 1
       RETURN
    END IF

    CALL GET_COMMAND_ARGUMENT(2, ARG, TMP, INFO)
    IF (INFO .NE. 0) THEN
       INFO = -2
       RETURN
    END IF
    READ (ARG,*) M
    IF (M .LE. 0) THEN
       INFO = 2
       RETURN
    END IF

    CALL GET_COMMAND_ARGUMENT(3, ARG, TMP, INFO)
    IF (INFO .NE. 0) THEN
       INFO = -3
       RETURN
    END IF
    READ (ARG,*) N
    IF (N .LE. 0) THEN
       INFO = 3
       RETURN
    END IF

    CALL GET_COMMAND_ARGUMENT(4, ARG, TMP, INFO)
    IF (INFO .NE. 0) THEN
       INFO = -4
       RETURN
    END IF
    READ (ARG,*) JSTRAT
    IF ((JSTRAT .LT. 0) .OR. (JSTRAT .GT. JSMMWC)) THEN
       INFO = 4
       RETURN
    END IF

    CALL GET_COMMAND_ARGUMENT(5, ARG, TMP, INFO)
    IF (INFO .NE. 0) THEN
       INFO = -5
       RETURN
    END IF
    READ (ARG,*) NSWP
    IF (NSWP .LT. 0) THEN
       INFO = 5
       RETURN
    END IF

    CALL GET_COMMAND_ARGUMENT(6, ARG, TMP, INFO)
    IF (INFO .NE. 0) THEN
       INFO = -6
       RETURN
    END IF
    READ (ARG,*) TPC
    IF ((TPC .LT. 0) .OR. (TPC .GT. MAXTPC)) THEN
       INFO = 6
       RETURN
    END IF
  END SUBROUTINE READCL

  SUBROUTINE BOPEN_YWJ_RO(FN, M, N, SZ, FD, INFO)
    IMPLICIT NONE
    CHARACTER(LEN=*,KIND=c_char), INTENT(IN) :: FN
    INTEGER, INTENT(IN) :: M, N
    INTEGER, INTENT(OUT) :: SZ(3), FD(3), INFO

    INTEGER :: EXPTSZ(3), DIFFSZ(3)

    SZ = -1
    FD = -1

    INFO = 0
    IF (N .LT. 0) INFO = -3
    IF (M .LT. 0) INFO = -2
    IF (INFO .NE. 0) RETURN

    EXPTSZ(1) = M * N * C_SIZEOF(Z_ZERO)
    EXPTSZ(2) = M * N * C_SIZEOF(Z_ZERO)
    EXPTSZ(3) = M     * C_SIZEOF(0)

    DIFFSZ = 0

    CALL BOPEN_RO((TRIM(FN)//c_char_'.Y'), SZ(1), FD(1))
    IF (FD(1) .LT. 0) THEN
       INFO = 1
       GOTO 1
    END IF
    DIFFSZ(1) = SZ(1) - EXPTSZ(1)
    IF (DIFFSZ(1) .NE. 0) THEN
       INFO = 1
       GOTO 1
    END IF
 
    CALL BOPEN_RO((TRIM(FN)//c_char_'.W'), SZ(2), FD(2))
    IF (FD(2) .LT. 0) THEN
       INFO = 2
       GOTO 1
    END IF
    DIFFSZ(2) = SZ(2) - EXPTSZ(2)
    IF (DIFFSZ(2) .NE. 0) THEN
       INFO = 2
       GOTO 1
    END IF

    CALL BOPEN_RO((TRIM(FN)//c_char_'.J'), SZ(3), FD(3))
    IF (FD(3) .LT. 0) THEN
       INFO = 3
       GOTO 1
    END IF
    DIFFSZ(3) = SZ(3) - EXPTSZ(3)
    IF (DIFFSZ(3) .NE. 0) THEN
       INFO = 3
       GOTO 1
    END IF

    RETURN

1   SZ = DIFFSZ
  END SUBROUTINE BOPEN_YWJ_RO

  SUBROUTINE BREAD_YWJ(FD, Y, LDY, W, LDW, J8, M, N, SZ, INFO)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: FD(3), M, N, LDY, LDW
    DOUBLE COMPLEX, INTENT(OUT), TARGET :: Y(LDY,N), W(LDW,N)
    INTEGER, INTENT(OUT), TARGET :: J8(M)
    INTEGER, INTENT(OUT) :: SZ(3), INFO

    INTEGER :: I, J, TN, NT

    SZ(1) = M * C_SIZEOF(Z_ZERO)
    SZ(2) = M * C_SIZEOF(Z_ZERO)
    SZ(3) =     C_SIZEOF(0)
    INFO = 0

    !$OMP PARALLEL DEFAULT(NONE) PRIVATE(I,J,TN,NT) SHARED(Y,W,J8,M,N,FD,SZ) REDUCTION(MAX:INFO)
    INFO = 0
    !$OMP DO
    DO J = 1, N
       I = BREAD(FD(1), C_LOC(Y(1,J)), SZ(1), (J-1) * SZ(1))
       IF (I .NE. SZ(1)) INFO = MAX(INFO,1)
       I = BREAD(FD(2), C_LOC(W(1,J)), SZ(2), (J-1) * SZ(2))
       IF (I .NE. SZ(2)) INFO = MAX(INFO,2)
    END DO
    !$OMP END DO
    TN = OMP_GET_THREAD_NUM()
    NT = OMP_GET_NUM_THREADS()
    IF (TN .EQ. 0) THEN
       I = (M / NT) + MOD(M,NT)
       J = 0
    ELSE ! TN .GT. 0
       I = M / NT
       J = TN * I + MOD(M,NT)
    END IF
    IF (I .GT. 0) THEN
       I = I * SZ(3)
       J = BREAD(FD(3), C_LOC(J8(J+1)), I, J * SZ(3))
       IF (J .NE. I) INFO = MAX(INFO,3)
    END IF
    !$OMP END PARALLEL

    SZ(1) = SZ(1) * N
    SZ(2) = SZ(2) * N
    SZ(3) = SZ(3) * M
  END SUBROUTINE BREAD_YWJ

  SUBROUTINE BOPEN_EZS_RW(FN, M, N, SZ, FD, INFO)
    IMPLICIT NONE
    CHARACTER(LEN=*,KIND=c_char), INTENT(IN) :: FN
    INTEGER, INTENT(IN) :: M, N
    INTEGER, INTENT(OUT) :: SZ(9), FD(9), INFO

    SZ = -1
    FD = -1

    INFO = 0
    IF (N .LT. 0) INFO = -3
    IF (M .LT. 0) INFO = -2
    IF (INFO .NE. 0) RETURN

    SZ(1) =     N * C_SIZEOF(D_ZERO) !  E
    SZ(2) = N * N * C_SIZEOF(Z_ZERO) !  Z

    SZ(3) =     N * C_SIZEOF(D_ZERO) ! SS
    SZ(4) = M * N * C_SIZEOF(Z_ZERO) ! YU
    SZ(5) =     N * C_SIZEOF(D_ZERO) ! EY
    SZ(6) =     N * C_SIZEOF(D_ZERO) ! SY
    SZ(7) = M * N * C_SIZEOF(Z_ZERO) ! WV
    SZ(8) =     N * C_SIZEOF(D_ZERO) ! EW
    SZ(9) =     N * C_SIZEOF(D_ZERO) ! SW

    CALL BOPEN_RW((TRIM(FN)//c_char_'.E'), SZ(1), FD(1))
    IF (FD(1) .LT. 0) THEN
       INFO = 1
       RETURN
    END IF

    CALL BOPEN_RW((TRIM(FN)//c_char_'.Z'), SZ(2), FD(2))
    IF (FD(2) .LT. 0) THEN
       INFO = 2
       RETURN
    END IF

    CALL BOPEN_RW((TRIM(FN)//c_char_'.SS'), SZ(3), FD(3))
    IF (FD(3) .LT. 0) THEN
       INFO = 3
       RETURN
    END IF

    CALL BOPEN_RW((TRIM(FN)//c_char_'.YU'), SZ(4), FD(4))
    IF (FD(4) .LT. 0) THEN
       INFO = 4
       RETURN
    END IF

    CALL BOPEN_RW((TRIM(FN)//c_char_'.EY'), SZ(5), FD(5))
    IF (FD(5) .LT. 0) THEN
       INFO = 5
       RETURN
    END IF

    CALL BOPEN_RW((TRIM(FN)//c_char_'.SY'), SZ(6), FD(6))
    IF (FD(6) .LT. 0) THEN
       INFO = 6
       RETURN
    END IF

    CALL BOPEN_RW((TRIM(FN)//c_char_'.WV'), SZ(7), FD(7))
    IF (FD(7) .LT. 0) THEN
       INFO = 7
       RETURN
    END IF

    CALL BOPEN_RW((TRIM(FN)//c_char_'.EW'), SZ(8), FD(8))
    IF (FD(8) .LT. 0) THEN
       INFO = 8
       RETURN
    END IF

    CALL BOPEN_RW((TRIM(FN)//c_char_'.SW'), SZ(9), FD(9))
    IF (FD(9) .LT. 0) THEN
       INFO = 9
       RETURN
    END IF
  END SUBROUTINE BOPEN_EZS_RW

  SUBROUTINE BWRITE_EZS(FD, E, Z, LDZ, SS, YU, LDY, EY, SY, WV, LDW, EW, SW, M, N, SZ, INFO)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: FD(9), M, N, LDZ, LDY, LDW
    DOUBLE PRECISION, INTENT(IN), TARGET :: E(N)
    DOUBLE COMPLEX, INTENT(IN), TARGET :: Z(LDZ,N)
    DOUBLE PRECISION, INTENT(IN), TARGET :: SS(N)
    DOUBLE PRECISION, INTENT(IN), TARGET :: EY(N)
    DOUBLE PRECISION, INTENT(IN), TARGET :: SY(N)
    DOUBLE PRECISION, INTENT(IN), TARGET :: EW(N)
    DOUBLE PRECISION, INTENT(IN), TARGET :: SW(N)
    DOUBLE COMPLEX, INTENT(IN), TARGET :: YU(LDY,N)
    DOUBLE COMPLEX, INTENT(IN), TARGET :: WV(LDW,N)
    INTEGER, INTENT(OUT) :: SZ(9), INFO

    INTEGER :: I, J, TN, NT

    SZ(1) =     C_SIZEOF(D_ZERO) !  E
    SZ(2) = N * C_SIZEOF(Z_ZERO) !  Z

    SZ(3) =     C_SIZEOF(D_ZERO) ! SS
    SZ(4) = M * C_SIZEOF(Z_ZERO) ! YU
    SZ(5) =     C_SIZEOF(D_ZERO) ! EY
    SZ(6) =     C_SIZEOF(D_ZERO) ! SY
    SZ(7) = M * C_SIZEOF(Z_ZERO) ! WV
    SZ(8) =     C_SIZEOF(D_ZERO) ! EW
    SZ(9) =     C_SIZEOF(D_ZERO) ! SW

    INFO = 0

    !$OMP PARALLEL DEFAULT(NONE) PRIVATE(I,J,TN,NT) SHARED(E,Z,SS,EY,SY,EW,SW,YU,WV,N,FD,SZ) REDUCTION(MAX:INFO)
    INFO = 0
    !$OMP DO
    DO J = 1, N
       I = BWRITE(FD(2), C_LOC(Z(1,J)), SZ(2), (J-1) * SZ(2))
       IF (I .NE. SZ(2)) INFO = MAX(INFO,2)
       I = BWRITE(FD(4), C_LOC(YU(1,J)), SZ(4), (J-1) * SZ(4))
       IF (I .NE. SZ(4)) INFO = MAX(INFO,4)
       I = BWRITE(FD(7), C_LOC(WV(1,J)), SZ(7), (J-1) * SZ(7))
       IF (I .NE. SZ(7)) INFO = MAX(INFO,7)
    END DO
    !$OMP END DO
    TN = OMP_GET_THREAD_NUM()
    NT = OMP_GET_NUM_THREADS()
    IF (TN .EQ. 0) THEN
       I = (N / NT) + MOD(N,NT)
       J = 0
    ELSE ! TN .GT. 0
       I = N / NT
       J = TN * I + MOD(N,NT)
    END IF
    IF (I .GT. 0) THEN       
       IF (BWRITE(FD(1), C_LOC(E(J+1)), I * SZ(1), J * SZ(1)) .NE. (I * SZ(1))) INFO = MAX(INFO,1)
       IF (BWRITE(FD(3), C_LOC(SS(J+1)), I * SZ(3), J * SZ(3)) .NE. (I * SZ(3))) INFO = MAX(INFO,3)
       IF (BWRITE(FD(5), C_LOC(EY(J+1)), I * SZ(5), J * SZ(5)) .NE. (I * SZ(5))) INFO = MAX(INFO,5)
       IF (BWRITE(FD(6), C_LOC(SY(J+1)), I * SZ(6), J * SZ(6)) .NE. (I * SZ(6))) INFO = MAX(INFO,6)
       IF (BWRITE(FD(8), C_LOC(EW(J+1)), I * SZ(8), J * SZ(8)) .NE. (I * SZ(8))) INFO = MAX(INFO,8)
       IF (BWRITE(FD(9), C_LOC(SW(J+1)), I * SZ(9), J * SZ(9)) .NE. (I * SZ(9))) INFO = MAX(INFO,9)
    END IF
    !$OMP END PARALLEL

    SZ(1) = SZ(1) * N
    SZ(2) = SZ(2) * N
    SZ(3) = SZ(3) * N
    SZ(4) = SZ(4) * N
    SZ(5) = SZ(5) * N
    SZ(6) = SZ(6) * N
    SZ(7) = SZ(7) * N
    SZ(8) = SZ(8) * N
    SZ(9) = SZ(9) * N
  END SUBROUTINE BWRITE_EZS

END PROGRAM ZHZL1SPT
