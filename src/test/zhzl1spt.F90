PROGRAM ZHZL1SPT
  USE BINIO
  USE HIF_HZ
  USE TIMER
  IMPLICIT NONE

  CHARACTER(LEN=FNL,KIND=c_char) :: FN
  INTEGER :: M,N,NSWP,TPC, LDH,LDS,LDZ, JSTRAT,NPAIRS,NSTEPS, I,FD(9),SZ(9), NROT(2),INFO

  INTEGER, TARGET :: JS(JSMLEX)
  !DIR$ ATTRIBUTES ALIGN:ALIGNB :: JS

  INTEGER, ALLOCATABLE, TARGET :: JSPAIR(:,:,:), J(:)
  !DIR$ ATTRIBUTES ALIGN:ALIGNB :: JSPAIR, J
  DOUBLE COMPLEX, ALLOCATABLE, TARGET :: H(:,:),S(:,:)
  !DIR$ ATTRIBUTES ALIGN:ALIGNB :: H,S
  DOUBLE COMPLEX, ALLOCATABLE :: Z(:,:)
  !DIR$ ATTRIBUTES ALIGN:ALIGNB :: Z
  DOUBLE PRECISION, ALLOCATABLE, TARGET :: E(:),EY(:),EW(:), SY(:),SW(:),SS(:)
  !DIR$ ATTRIBUTES ALIGN:ALIGNB :: E,EY,EW, SY,SW,SS

  CALL READCL(FN, M, N, JSTRAT, NSWP, TPC, INFO)
  IF (INFO .NE. 0) STOP 'Error in READCL'
  IF (N .GT. M) STOP 'N > M'
  INFO = MOD(N, 2)
  IF (INFO .NE. 0) STOP 'N mod 2 =/= 0'
  NPAIRS = N / 2
  LDH = M
  INFO = MOD(LDH, ZALIGN)
  IF (INFO .NE. 0) STOP 'LDH mod ZALIGN =/= 0'
  LDS = M
  INFO = MOD(LDS, ZALIGN)
  IF (INFO .NE. 0) STOP 'LDS mod ZALIGN =/= 0'
  LDZ = N
  INFO = MOD(LDZ, ZALIGN)
  IF (INFO .NE. 0) STOP 'LDZ mod ZALIGN =/= 0'

  SELECT CASE (JSTRAT)
  CASE (JSMENC,JSMMNC)
     CONTINUE
  CASE DEFAULT
     STOP 'JSTRAT not JSMENC(2) nor JSMMNC(4)'
  END SELECT
  CALL JSTRAT_INIT(JS, JSTRAT, N, NSTEPS)
  IF (NSTEPS .LE. 0) STOP 'Error in JSTRAT_INIT'
  ALLOCATE(JSPAIR(2,NPAIRS,NSTEPS),STAT=INFO)
  IF (INFO .GT. 0) STOP 'Error allocating JSPAIR'
  CALL JSTRAT_SWEEP_NC(JS, NSTEPS, NPAIRS, JSPAIR, INFO)
  IF (INFO .NE. 0) STOP 'Error in JSTRAT_NEXT/UNPACK_NC'

  CALL BOPEN_YWJ_RO(FN, M, N, SZ, FD, INFO)
  IF (INFO .NE. 0) STOP 'Error in BOPEN_YWJ_RO'
  ALLOCATE(H(LDH,N),STAT=INFO)
  IF (INFO .GT. 0) STOP 'Error allocating H'
  ALLOCATE(S(LDS,N),STAT=INFO)
  IF (INFO .GT. 0) STOP 'Error allocating S'
  ALLOCATE(J(M),STAT=INFO)
  IF (INFO .GT. 0) STOP 'Error allocating J'
  CALL BREAD_YWJ(FD, H, S, J, M, N, SZ, INFO)
  IF (INFO .NE. 0) STOP 'Error in BREAD_YWJ'
  CALL BCLOSEN(FD, 3)
  ALLOCATE(Z(LDZ,N),STAT=INFO)
  IF (INFO .GT. 0) STOP 'Error allocating Z'
  ALLOCATE(E(N),STAT=INFO)
  IF (INFO .GT. 0) STOP 'Error allocating E'

  ALLOCATE(EY(N),STAT=INFO)
  IF (INFO .GT. 0) STOP 'Error allocating EY'
  ALLOCATE(EW(N),STAT=INFO)
  IF (INFO .GT. 0) STOP 'Error allocating EW'
  ALLOCATE(SY(N),STAT=INFO)
  IF (INFO .GT. 0) STOP 'Error allocating SY'
  ALLOCATE(SW(N),STAT=INFO)
  IF (INFO .GT. 0) STOP 'Error allocating SW'
  ALLOCATE(SS(N),STAT=INFO)
  IF (INFO .GT. 0) STOP 'Error allocating SS'

  INFO = BLAS_PREPARE()
  I = GET_THREAD_NS()
  IF (TPC .EQ. 0) THEN
     CALL ZHZL1S(M,N, H,LDH, J, S,LDS, Z,LDZ, JS,JSPAIR, NSWP, E,EY,EW, SY,SW,SS, NROT,INFO)
  ELSE
     CALL ZHZL1P(M,N, H,LDH, J, S,LDS, Z,LDZ, JS,JSPAIR, NSWP,TPC, E,EY,EW, SY,SW,SS, NROT,INFO)
  END IF
  I = GET_THREAD_NS() - I
  WRITE (UOUT,'(2(I6,A),I1,A,I3,A,2(I20,A),F15.6)') &
       M,',',N,',',JSTRAT,',',INFO,',',NROT(1),',',NROT(2),',',(I*DNS2S)

  CALL BOPEN_EZS_RW(FN, M, N, SZ, FD, INFO)
  IF (INFO .NE. 0) STOP 'Error in BOPEN_EZS_RW'
  CALL BWRITE_EZS(FD, E, Z, SS, H, EY, SY, S, EW, SW, M, N, INFO)
  IF (INFO .NE. 0) STOP 'Error in BWRITE_EZS'
  CALL BCLOSEN(FD, 9)

  IF (ALLOCATED(SS)) DEALLOCATE(SS)
  IF (ALLOCATED(SW)) DEALLOCATE(SW)
  IF (ALLOCATED(SY)) DEALLOCATE(SY)
  IF (ALLOCATED(EW)) DEALLOCATE(EW)
  IF (ALLOCATED(EY)) DEALLOCATE(EY)

  IF (ALLOCATED(E)) DEALLOCATE(E)
  IF (ALLOCATED(Z)) DEALLOCATE(Z)
  IF (ALLOCATED(J)) DEALLOCATE(J)
  IF (ALLOCATED(S)) DEALLOCATE(S)
  IF (ALLOCATED(H)) DEALLOCATE(H)

CONTAINS

  SUBROUTINE READCL(FN, M, N, JSTRAT, NSWP, TPC, INFO)
    IMPLICIT NONE
    CHARACTER(LEN=*,KIND=c_char), INTENT(OUT) :: FN
    INTEGER, INTENT(OUT) :: M, N, JSTRAT, NSWP, TPC, INFO

    CHARACTER(LEN=FNL) :: ARG
    INTEGER :: TMP

    INFO = 0
    IF (COMMAND_ARGUMENT_COUNT() .NE. 6) STOP 'zhzl1spt.exe FN M N JSTRAT NSWP TPC'

    CALL GET_COMMAND_ARGUMENT(1, ARG, TMP, INFO)
    IF (INFO .NE. 0) THEN
       INFO = -1
       RETURN
    END IF
    FN = TRIM(ARG)
    IF (LEN_TRIM(FN) .LE. 0) THEN
       INFO = 1
       RETURN
    END IF

    CALL GET_COMMAND_ARGUMENT(2, ARG, TMP, INFO)
    IF (INFO .NE. 0) THEN
       INFO = -2
       RETURN
    END IF
    READ (ARG,*) M
    IF (M .LE. 0) THEN
       INFO = 2
       RETURN
    END IF

    CALL GET_COMMAND_ARGUMENT(3, ARG, TMP, INFO)
    IF (INFO .NE. 0) THEN
       INFO = -3
       RETURN
    END IF
    READ (ARG,*) N
    IF (N .LE. 0) THEN
       INFO = 3
       RETURN
    END IF

    CALL GET_COMMAND_ARGUMENT(4, ARG, TMP, INFO)
    IF (INFO .NE. 0) THEN
       INFO = -4
       RETURN
    END IF
    READ (ARG,*) JSTRAT
    IF ((JSTRAT .LT. 0) .OR. (JSTRAT .GT. JSMMWC)) THEN
       INFO = 4
       RETURN
    END IF

    CALL GET_COMMAND_ARGUMENT(5, ARG, TMP, INFO)
    IF (INFO .NE. 0) THEN
       INFO = -5
       RETURN
    END IF
    READ (ARG,*) NSWP
    IF (NSWP .LT. 0) THEN
       INFO = 5
       RETURN
    END IF

    CALL GET_COMMAND_ARGUMENT(6, ARG, TMP, INFO)
    IF (INFO .NE. 0) THEN
       INFO = -6
       RETURN
    END IF
    READ (ARG,*) TPC
    IF ((TPC .LT. 0) .OR. (TPC .GT. MAXTPC)) THEN
       INFO = 6
       RETURN
    END IF
  END SUBROUTINE READCL

  SUBROUTINE BOPEN_YWJ_RO(FN, M, N, SZ, FD, INFO)
    IMPLICIT NONE
    CHARACTER(LEN=*,KIND=c_char), INTENT(IN) :: FN
    INTEGER, INTENT(IN) :: M, N
    INTEGER, INTENT(OUT) :: SZ(3), FD(3), INFO

    INTEGER :: EXPTSZ(3), DIFFSZ(3)

    SZ = -1
    FD = -1

    INFO = 0
    IF (N .LT. 0) INFO = -3
    IF (M .LT. 0) INFO = -2
    IF (INFO .NE. 0) RETURN

    EXPTSZ(1) = M * N * C_SIZEOF(Z_ZERO)
    EXPTSZ(2) = M * N * C_SIZEOF(Z_ZERO)
    EXPTSZ(3) = M     * C_SIZEOF(0)

    DIFFSZ = 0

    CALL BOPEN_RO((TRIM(FN)//c_char_'.Y'), SZ(1), FD(1))
    IF (FD(1) .LT. 0) THEN
       INFO = 1
       GOTO 1
    END IF
    DIFFSZ(1) = SZ(1) - EXPTSZ(1)
    IF (DIFFSZ(1) .NE. 0) THEN
       INFO = 1
       GOTO 1
    END IF
 
    CALL BOPEN_RO((TRIM(FN)//c_char_'.W'), SZ(2), FD(2))
    IF (FD(2) .LT. 0) THEN
       INFO = 2
       GOTO 1
    END IF
    DIFFSZ(2) = SZ(2) - EXPTSZ(2)
    IF (DIFFSZ(2) .NE. 0) THEN
       INFO = 2
       GOTO 1
    END IF

    CALL BOPEN_RO((TRIM(FN)//c_char_'.J'), SZ(3), FD(3))
    IF (FD(3) .LT. 0) THEN
       INFO = 3
       GOTO 1
    END IF
    DIFFSZ(3) = SZ(3) - EXPTSZ(3)
    IF (DIFFSZ(3) .NE. 0) THEN
       INFO = 3
       GOTO 1
    END IF

    RETURN

1   SZ = DIFFSZ
  END SUBROUTINE BOPEN_YWJ_RO

  SUBROUTINE BREAD_YWJ(FD, Y, W, J, M, N, SZ, INFO)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: FD(3), M, N
    DOUBLE COMPLEX, INTENT(OUT), TARGET :: Y(M,N), W(M,N)
    INTEGER, INTENT(OUT), TARGET :: J(M)
    INTEGER, INTENT(OUT) :: SZ(3), INFO

    INFO = 0

    SZ(1) = BREAD(FD(1), C_LOC(Y), C_SIZEOF(Y), 0)
    IF (SZ(1) .NE. C_SIZEOF(Y)) THEN
       INFO = 1
       RETURN
    END IF

    SZ(2) = BREAD(FD(2), C_LOC(W), C_SIZEOF(W), 0)
    IF (SZ(2) .NE. C_SIZEOF(W)) THEN
       INFO = 2
       RETURN
    END IF

    SZ(3) = BREAD(FD(3), C_LOC(J), C_SIZEOF(J), 0)
    IF (SZ(3) .NE. C_SIZEOF(J)) THEN
       INFO = 3
       RETURN
    END IF
  END SUBROUTINE BREAD_YWJ

  SUBROUTINE BOPEN_EZS_RW(FN, M, N, SZ, FD, INFO)
    IMPLICIT NONE
    CHARACTER(LEN=*,KIND=c_char), INTENT(IN) :: FN
    INTEGER, INTENT(IN) :: M, N
    INTEGER, INTENT(OUT) :: SZ(9), FD(9), INFO

    SZ = -1
    FD = -1

    INFO = 0
    IF (N .LT. 0) INFO = -3
    IF (M .LT. 0) INFO = -2
    IF (INFO .NE. 0) RETURN

    SZ(1) =     N * C_SIZEOF(D_ZERO) !  E
    SZ(2) = N * N * C_SIZEOF(Z_ZERO) !  Z

    SZ(3) =     N * C_SIZEOF(D_ZERO) ! SS
    SZ(4) = M * N * C_SIZEOF(Z_ZERO) ! YU
    SZ(5) =     N * C_SIZEOF(D_ZERO) ! EY
    SZ(6) =     N * C_SIZEOF(D_ZERO) ! SY
    SZ(7) = M * N * C_SIZEOF(Z_ZERO) ! WV
    SZ(8) =     N * C_SIZEOF(D_ZERO) ! EW
    SZ(9) =     N * C_SIZEOF(D_ZERO) ! SW

    CALL BOPEN_RW((TRIM(FN)//c_char_'.E'), SZ(1), FD(1))
    IF (FD(1) .LT. 0) THEN
       INFO = 1
       RETURN
    END IF

    CALL BOPEN_RW((TRIM(FN)//c_char_'.Z'), SZ(2), FD(2))
    IF (FD(2) .LT. 0) THEN
       INFO = 2
       RETURN
    END IF

    CALL BOPEN_RW((TRIM(FN)//c_char_'.SS'), SZ(3), FD(3))
    IF (FD(3) .LT. 0) THEN
       INFO = 3
       RETURN
    END IF

    CALL BOPEN_RW((TRIM(FN)//c_char_'.YU'), SZ(4), FD(4))
    IF (FD(4) .LT. 0) THEN
       INFO = 4
       RETURN
    END IF

    CALL BOPEN_RW((TRIM(FN)//c_char_'.EY'), SZ(5), FD(5))
    IF (FD(5) .LT. 0) THEN
       INFO = 5
       RETURN
    END IF

    CALL BOPEN_RW((TRIM(FN)//c_char_'.SY'), SZ(6), FD(6))
    IF (FD(6) .LT. 0) THEN
       INFO = 6
       RETURN
    END IF

    CALL BOPEN_RW((TRIM(FN)//c_char_'.WV'), SZ(7), FD(7))
    IF (FD(7) .LT. 0) THEN
       INFO = 7
       RETURN
    END IF

    CALL BOPEN_RW((TRIM(FN)//c_char_'.EW'), SZ(8), FD(8))
    IF (FD(8) .LT. 0) THEN
       INFO = 8
       RETURN
    END IF

    CALL BOPEN_RW((TRIM(FN)//c_char_'.SW'), SZ(9), FD(9))
    IF (FD(9) .LT. 0) THEN
       INFO = 9
       RETURN
    END IF
  END SUBROUTINE BOPEN_EZS_RW

  SUBROUTINE BWRITE_EZS(FD, E, Z, SS, YU, EY, SY, WV, EW, SW, M, N, INFO)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: FD(9), M, N
    DOUBLE PRECISION, INTENT(IN), TARGET :: E(N)
    DOUBLE COMPLEX, INTENT(IN), TARGET :: Z(N,N)
    DOUBLE PRECISION, INTENT(IN), TARGET :: SS(N)
    DOUBLE PRECISION, INTENT(IN), TARGET :: EY(N)
    DOUBLE PRECISION, INTENT(IN), TARGET :: SY(N)
    DOUBLE PRECISION, INTENT(IN), TARGET :: EW(N)
    DOUBLE PRECISION, INTENT(IN), TARGET :: SW(N)
    DOUBLE COMPLEX, INTENT(IN), TARGET :: YU(M,N)
    DOUBLE COMPLEX, INTENT(IN), TARGET :: WV(M,N)
    INTEGER, INTENT(OUT) :: INFO

    INTEGER(c_size_t) :: SZ(9), S

    SZ(1) =     N * C_SIZEOF(D_ZERO) !  E
    SZ(2) = N * N * C_SIZEOF(Z_ZERO) !  Z

    SZ(3) =     N * C_SIZEOF(D_ZERO) ! SS
    SZ(4) = M * N * C_SIZEOF(Z_ZERO) ! YU
    SZ(5) =     N * C_SIZEOF(D_ZERO) ! EY
    SZ(6) =     N * C_SIZEOF(D_ZERO) ! SY
    SZ(7) = M * N * C_SIZEOF(Z_ZERO) ! WV
    SZ(8) =     N * C_SIZEOF(D_ZERO) ! EW
    SZ(9) =     N * C_SIZEOF(D_ZERO) ! SW

    INFO = 0

    S = BWRITE(FD(1), C_LOC(E), C_SIZEOF(E), 0)
    IF (S .NE. SZ(1)) INFO = 1
    S = BWRITE(FD(2), C_LOC(Z), C_SIZEOF(Z), 0)
    IF (S .NE. SZ(2)) INFO = 2

    S = BWRITE(FD(3), C_LOC(SS), C_SIZEOF(SS), 0)
    IF (S .NE. SZ(3)) INFO = 3
    S = BWRITE(FD(4), C_LOC(YU), C_SIZEOF(YU), 0)
    IF (S .NE. SZ(4)) INFO = 4
    S = BWRITE(FD(5), C_LOC(EY), C_SIZEOF(EY), 0)
    IF (S .NE. SZ(5)) INFO = 5
    S = BWRITE(FD(6), C_LOC(SY), C_SIZEOF(SY), 0)
    IF (S .NE. SZ(6)) INFO = 6
    S = BWRITE(FD(7), C_LOC(WV), C_SIZEOF(WV), 0)
    IF (S .NE. SZ(7)) INFO = 7
    S = BWRITE(FD(8), C_LOC(EW), C_SIZEOF(EW), 0)
    IF (S .NE. SZ(8)) INFO = 8
    S = BWRITE(FD(9), C_LOC(SW), C_SIZEOF(SW), 0)
    IF (S .NE. SZ(9)) INFO = 9
  END SUBROUTINE BWRITE_EZS

END PROGRAM ZHZL1SPT
