PROGRAM ZGENT
  USE BINIO
  USE BLAS_UTILS
  USE OMP_LIB
  IMPLICIT NONE

  CHARACTER, PARAMETER :: DIST = 'U', PACK = 'N'
  INTEGER, PARAMETER :: SEED(4) = (/ 11, 13, 17, 19 /), MODE = 6
  REAL(KIND=DWP), PARAMETER :: COND = D_ONE, DMAX = D_ONE
  
  CHARACTER(LEN=FNL,KIND=c_char) :: FN
  CHARACTER :: SYM
  INTEGER :: M, N, KL, KU, LDA, INFO, ISEED(4), FD, SZ

  COMPLEX(KIND=DWP), ALLOCATABLE, TARGET :: A(:,:)
  !DIR$ ATTRIBUTES ALIGN:ALIGNB :: A
  REAL(KIND=DWP), ALLOCATABLE :: D(:)
  INTEGER, ALLOCATABLE, TARGET :: J(:)
  COMPLEX(KIND=DWP), ALLOCATABLE :: WORK(:)
#ifdef USE_X200
  !DIR$ ATTRIBUTES MEMKIND:HBW, ALIGN:ALIGNB :: D,J,WORK
#else
  !DIR$ ATTRIBUTES ALIGN:ALIGNB :: D,J,WORK
#endif

  EXTERNAL :: ZLATMS

  CALL READCL(M, N, FN, INFO)
  IF (INFO .NE. 0) THEN
     WRITE (ULOG,'(I2,A)',ADVANCE='NO') INFO, ' '
     STOP 'READCL'
  END IF

  INFO = BLAS_PREPARE()

  LDA = M; ALLOCATE(A(LDA,N)); A = Z_ZERO
  ALLOCATE(D(N)); D = D_ZERO
  ALLOCATE(WORK(3*M)); WORK = Z_ZERO

  ISEED = SEED
  IF (M .EQ. N) THEN
     SYM = 'P'
  ELSE
     SYM = 'N'
  END IF
  KL = M - 1
  KU = N - 1

  ! generate F
  CALL ZLATMS(M, N, DIST, ISEED, SYM, D, MODE, COND, DMAX, KL, KU, PACK, A, LDA, WORK, INFO)
  IF (INFO .NE. 0) THEN
     WRITE (ULOG,'(I5,A)',ADVANCE='NO') INFO, ' '
     STOP 'ZLATMS 1'
  END IF

  FD = -1
  SZ = M * N * C_SIZEOF(Z_ZERO)
  CALL BOPEN_RW((TRIM(FN)//c_char_'.Y'), SZ, FD)
  IF (FD .LT. 0) STOP 'BOPEN_Y_RW'
  CALL BWRITE_YW(FD, A, M, N, SZ, INFO)
  IF (INFO .NE. 0) STOP 'BWRITE_Y'
  CALL BCLOSE(FD)

  ! generate G
  CALL ZLATMS(M, N, DIST, ISEED, SYM, D, MODE, COND, DMAX, KL, KU, PACK, A, LDA, WORK, INFO)
  IF (INFO .NE. 0) THEN
     WRITE (ULOG,'(I5,A)',ADVANCE='NO') INFO, ' '
     STOP 'ZLATMS 2'
  END IF

  CALL BOPEN_RW((TRIM(FN)//c_char_'.W'), SZ, FD)
  IF (FD .LT. 0) STOP 'BOPEN_W_RW'
  CALL BWRITE_YW(FD, A, M, N, SZ, INFO)
  IF (INFO .NE. 0) STOP 'BWRITE_W'
  CALL BCLOSE(FD)

  IF (ALLOCATED(WORK)) DEALLOCATE(WORK)
  IF (ALLOCATED(D)) DEALLOCATE(D)
  IF (ALLOCATED(A)) DEALLOCATE(A)

  ALLOCATE(J(M))
  J = 1

  SZ = M * C_SIZEOF(0)
  CALL BOPEN_RW((TRIM(FN)//c_char_'.J'), SZ, FD)
  IF (FD .LT. 0) STOP 'BOPEN_J_RW'
  CALL BWRITE_J1(FD, J, M, SZ, INFO)
  IF (INFO .NE. 0) STOP 'BWRITE_J1'
  CALL BCLOSE(FD)

  IF (ALLOCATED(J)) DEALLOCATE(J)

CONTAINS

  SUBROUTINE READCL(M, N, FN, INFO)
    IMPLICIT NONE
    INTEGER, INTENT(OUT) :: M, N, INFO
    CHARACTER(LEN=*,KIND=c_char), INTENT(OUT) :: FN

    CHARACTER(LEN=FNL) :: ARG
    INTEGER :: TMP

    INFO = 0
    IF (COMMAND_ARGUMENT_COUNT() .NE. 3) STOP 'zgent.exe M N FN'
    ARG = '                        '
    TMP = 0

    CALL GET_COMMAND_ARGUMENT(1, ARG, TMP, INFO)
    IF (INFO .NE. 0) THEN
       INFO = -1
       RETURN
    END IF
    READ (ARG,*) M
    IF ((M .LE. 0) .OR. (MOD(M,2) .NE. 0)) THEN
       INFO = 1
       RETURN
    END IF

    CALL GET_COMMAND_ARGUMENT(2, ARG, TMP, INFO)
    IF (INFO .NE. 0) THEN
       INFO = -2
       RETURN
    END IF
    READ (ARG,*) N
    IF ((N .LE. 0) .OR. (M .LT. N)) THEN
       INFO = 2
       RETURN
    END IF

    CALL GET_COMMAND_ARGUMENT(3, ARG, TMP, INFO)
    IF (INFO .NE. 0) THEN
       INFO = -3
       RETURN
    END IF
    FN = TRIM(ARG)
    IF (LEN_TRIM(FN) .LE. 0) THEN
       INFO = 3
       RETURN
    END IF
  END SUBROUTINE READCL

  SUBROUTINE BWRITE_YW(FD, YW, M, N, SZ, INFO)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: FD, M, N
    COMPLEX(KIND=DWP), INTENT(IN), TARGET :: YW(M,N)
    INTEGER, INTENT(OUT) :: SZ, INFO

    INTEGER :: I, J

    SZ = M * C_SIZEOF(Z_ZERO)
    INFO = 0

    !$OMP PARALLEL DEFAULT(NONE) PRIVATE(I,J) SHARED(YW,N,FD,SZ) REDUCTION(MAX:INFO)
    INFO = 0
    !$OMP DO
    DO J = 1, N
       I = BWRITE(FD, C_LOC(YW(1,J)), SZ, (J-1) * SZ)
       IF (I .NE. SZ) INFO = MAX(INFO,J)
    END DO
    !$OMP END DO
    !$OMP END PARALLEL

    SZ = SZ * N
  END SUBROUTINE BWRITE_YW

  SUBROUTINE BWRITE_J1(FD, J1, M, SZ, INFO)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: FD, M
    INTEGER, INTENT(IN), TARGET :: J1(M)
    INTEGER, INTENT(OUT) :: SZ, INFO

    INTEGER :: I, J, TN, NT

    SZ = C_SIZEOF(0)
    INFO = 0

    !$OMP PARALLEL DEFAULT(NONE) PRIVATE(I,J,TN,NT) SHARED(J1,M,FD,SZ) REDUCTION(MAX:INFO)
    INFO = 0
    TN = INT(OMP_GET_THREAD_NUM())
    NT = INT(OMP_GET_NUM_THREADS())
    IF (TN .EQ. 0) THEN
       I = (M / NT) + MOD(M,NT)
       J = 0
    ELSE ! TN .GT. 0
       I = M / NT
       J = TN * I + MOD(M,NT)
    END IF
    IF (I .GT. 0) THEN
       I = I * SZ
       J = BWRITE(FD, C_LOC(J1(J+1)), I, J * SZ)
       IF (J .NE. I) INFO = MAX(INFO,(TN+1))
    END IF
    !$OMP END PARALLEL

    SZ = SZ * M
  END SUBROUTINE BWRITE_J1

END PROGRAM ZGENT
